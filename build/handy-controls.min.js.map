{"version":3,"file":"handy-controls.min.js","sources":["../node_modules/three/examples/jsm/libs/motion-controllers.module.js","../src/lib/XRControllerModelFactory.js","../src/handy-controls.js"],"sourcesContent":["/**\n * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles\n */\n\nconst Constants = {\n  Handedness: Object.freeze({\n    NONE: 'none',\n    LEFT: 'left',\n    RIGHT: 'right'\n  }),\n\n  ComponentState: Object.freeze({\n    DEFAULT: 'default',\n    TOUCHED: 'touched',\n    PRESSED: 'pressed'\n  }),\n\n  ComponentProperty: Object.freeze({\n    BUTTON: 'button',\n    X_AXIS: 'xAxis',\n    Y_AXIS: 'yAxis',\n    STATE: 'state'\n  }),\n\n  ComponentType: Object.freeze({\n    TRIGGER: 'trigger',\n    SQUEEZE: 'squeeze',\n    TOUCHPAD: 'touchpad',\n    THUMBSTICK: 'thumbstick',\n    BUTTON: 'button'\n  }),\n\n  ButtonTouchThreshold: 0.05,\n\n  AxisTouchThreshold: 0.1,\n\n  VisualResponseProperty: Object.freeze({\n    TRANSFORM: 'transform',\n    VISIBILITY: 'visibility'\n  })\n};\n\n/**\n * @description Static helper function to fetch a JSON file and turn it into a JS object\n * @param {string} path - Path to JSON file to be fetched\n */\nasync function fetchJsonFile(path) {\n  const response = await fetch(path);\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  } else {\n    return response.json();\n  }\n}\n\nasync function fetchProfilesList(basePath) {\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  }\n\n  const profileListFileName = 'profilesList.json';\n  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);\n  return profilesList;\n}\n\nasync function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {\n  if (!xrInputSource) {\n    throw new Error('No xrInputSource supplied');\n  }\n\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  }\n\n  // Get the list of profiles\n  const supportedProfilesList = await fetchProfilesList(basePath);\n\n  // Find the relative path to the first requested profile that is recognized\n  let match;\n  xrInputSource.profiles.some((profileId) => {\n    const supportedProfile = supportedProfilesList[profileId];\n    if (supportedProfile) {\n      match = {\n        profileId,\n        profilePath: `${basePath}/${supportedProfile.path}`,\n        deprecated: !!supportedProfile.deprecated\n      };\n    }\n    return !!match;\n  });\n\n  if (!match) {\n    if (!defaultProfile) {\n      throw new Error('No matching profile name found');\n    }\n\n    const supportedProfile = supportedProfilesList[defaultProfile];\n    if (!supportedProfile) {\n      throw new Error(`No matching profile name found and default profile \"${defaultProfile}\" missing.`);\n    }\n\n    match = {\n      profileId: defaultProfile,\n      profilePath: `${basePath}/${supportedProfile.path}`,\n      deprecated: !!supportedProfile.deprecated\n    };\n  }\n\n  const profile = await fetchJsonFile(match.profilePath);\n\n  let assetPath;\n  if (getAssetPath) {\n    let layout;\n    if (xrInputSource.handedness === 'any') {\n      layout = profile.layouts[Object.keys(profile.layouts)[0]];\n    } else {\n      layout = profile.layouts[xrInputSource.handedness];\n    }\n    if (!layout) {\n      throw new Error(\n        `No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`\n      );\n    }\n\n    if (layout.assetPath) {\n      assetPath = match.profilePath.replace('profile.json', layout.assetPath);\n    }\n  }\n\n  return { profile, assetPath };\n}\n\n/** @constant {Object} */\nconst defaultComponentValues = {\n  xAxis: 0,\n  yAxis: 0,\n  button: 0,\n  state: Constants.ComponentState.DEFAULT\n};\n\n/**\n * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad\n * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within\n * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical\n * range of motion and touchpads do not report touch locations off their physical bounds.\n * @param {number} x The original x coordinate in the range -1 to 1\n * @param {number} y The original y coordinate in the range -1 to 1\n */\nfunction normalizeAxes(x = 0, y = 0) {\n  let xAxis = x;\n  let yAxis = y;\n\n  // Determine if the point is outside the bounds of the circle\n  // and, if so, place it on the edge of the circle\n  const hypotenuse = Math.sqrt((x * x) + (y * y));\n  if (hypotenuse > 1) {\n    const theta = Math.atan2(y, x);\n    xAxis = Math.cos(theta);\n    yAxis = Math.sin(theta);\n  }\n\n  // Scale and move the circle so values are in the interpolation range.  The circle's origin moves\n  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.\n  const result = {\n    normalizedXAxis: (xAxis * 0.5) + 0.5,\n    normalizedYAxis: (yAxis * 0.5) + 0.5\n  };\n  return result;\n}\n\n/**\n * Contains the description of how the 3D model should visually respond to a specific user input.\n * This is accomplished by initializing the object with the name of a node in the 3D model and\n * property that need to be modified in response to user input, the name of the nodes representing\n * the allowable range of motion, and the name of the input which triggers the change. In response\n * to the named input changing, this object computes the appropriate weighting to use for\n * interpolating between the range of motion nodes.\n */\nclass VisualResponse {\n  constructor(visualResponseDescription) {\n    this.componentProperty = visualResponseDescription.componentProperty;\n    this.states = visualResponseDescription.states;\n    this.valueNodeName = visualResponseDescription.valueNodeName;\n    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;\n\n    if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {\n      this.minNodeName = visualResponseDescription.minNodeName;\n      this.maxNodeName = visualResponseDescription.maxNodeName;\n    }\n\n    // Initializes the response's current value based on default data\n    this.value = 0;\n    this.updateFromComponent(defaultComponentValues);\n  }\n\n  /**\n   * Computes the visual response's interpolation weight based on component state\n   * @param {Object} componentValues - The component from which to update\n   * @param {number} xAxis - The reported X axis value of the component\n   * @param {number} yAxis - The reported Y axis value of the component\n   * @param {number} button - The reported value of the component's button\n   * @param {string} state - The component's active state\n   */\n  updateFromComponent({\n    xAxis, yAxis, button, state\n  }) {\n    const { normalizedXAxis, normalizedYAxis } = normalizeAxes(xAxis, yAxis);\n    switch (this.componentProperty) {\n      case Constants.ComponentProperty.X_AXIS:\n        this.value = (this.states.includes(state)) ? normalizedXAxis : 0.5;\n        break;\n      case Constants.ComponentProperty.Y_AXIS:\n        this.value = (this.states.includes(state)) ? normalizedYAxis : 0.5;\n        break;\n      case Constants.ComponentProperty.BUTTON:\n        this.value = (this.states.includes(state)) ? button : 0;\n        break;\n      case Constants.ComponentProperty.STATE:\n        if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {\n          this.value = (this.states.includes(state));\n        } else {\n          this.value = this.states.includes(state) ? 1.0 : 0.0;\n        }\n        break;\n      default:\n        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);\n    }\n  }\n}\n\nclass Component {\n  /**\n   * @param {Object} componentId - Id of the component\n   * @param {Object} componentDescription - Description of the component to be created\n   */\n  constructor(componentId, componentDescription) {\n    if (!componentId\n     || !componentDescription\n     || !componentDescription.visualResponses\n     || !componentDescription.gamepadIndices\n     || Object.keys(componentDescription.gamepadIndices).length === 0) {\n      throw new Error('Invalid arguments supplied');\n    }\n\n    this.id = componentId;\n    this.type = componentDescription.type;\n    this.rootNodeName = componentDescription.rootNodeName;\n    this.touchPointNodeName = componentDescription.touchPointNodeName;\n\n    // Build all the visual responses for this component\n    this.visualResponses = {};\n    Object.keys(componentDescription.visualResponses).forEach((responseName) => {\n      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);\n      this.visualResponses[responseName] = visualResponse;\n    });\n\n    // Set default values\n    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);\n\n    this.values = {\n      state: Constants.ComponentState.DEFAULT,\n      button: (this.gamepadIndices.button !== undefined) ? 0 : undefined,\n      xAxis: (this.gamepadIndices.xAxis !== undefined) ? 0 : undefined,\n      yAxis: (this.gamepadIndices.yAxis !== undefined) ? 0 : undefined\n    };\n  }\n\n  get data() {\n    const data = { id: this.id, ...this.values };\n    return data;\n  }\n\n  /**\n   * @description Poll for updated data based on current gamepad state\n   * @param {Object} gamepad - The gamepad object from which the component data should be polled\n   */\n  updateFromGamepad(gamepad) {\n    // Set the state to default before processing other data sources\n    this.values.state = Constants.ComponentState.DEFAULT;\n\n    // Get and normalize button\n    if (this.gamepadIndices.button !== undefined\n        && gamepad.buttons.length > this.gamepadIndices.button) {\n      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];\n      this.values.button = gamepadButton.value;\n      this.values.button = (this.values.button < 0) ? 0 : this.values.button;\n      this.values.button = (this.values.button > 1) ? 1 : this.values.button;\n\n      // Set the state based on the button\n      if (gamepadButton.pressed || this.values.button === 1) {\n        this.values.state = Constants.ComponentState.PRESSED;\n      } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Get and normalize x axis value\n    if (this.gamepadIndices.xAxis !== undefined\n        && gamepad.axes.length > this.gamepadIndices.xAxis) {\n      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];\n      this.values.xAxis = (this.values.xAxis < -1) ? -1 : this.values.xAxis;\n      this.values.xAxis = (this.values.xAxis > 1) ? 1 : this.values.xAxis;\n\n      // If the state is still default, check if the xAxis makes it touched\n      if (this.values.state === Constants.ComponentState.DEFAULT\n        && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Get and normalize Y axis value\n    if (this.gamepadIndices.yAxis !== undefined\n        && gamepad.axes.length > this.gamepadIndices.yAxis) {\n      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];\n      this.values.yAxis = (this.values.yAxis < -1) ? -1 : this.values.yAxis;\n      this.values.yAxis = (this.values.yAxis > 1) ? 1 : this.values.yAxis;\n\n      // If the state is still default, check if the yAxis makes it touched\n      if (this.values.state === Constants.ComponentState.DEFAULT\n        && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Update the visual response weights based on the current component data\n    Object.values(this.visualResponses).forEach((visualResponse) => {\n      visualResponse.updateFromComponent(this.values);\n    });\n  }\n}\n\n/**\n  * @description Builds a motion controller with components and visual responses based on the\n  * supplied profile description. Data is polled from the xrInputSource's gamepad.\n  * @author Nell Waliczek / https://github.com/NellWaliczek\n*/\nclass MotionController {\n  /**\n   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around\n   * @param {Object} profile - The best matched profile description for the supplied xrInputSource\n   * @param {Object} assetUrl\n   */\n  constructor(xrInputSource, profile, assetUrl) {\n    if (!xrInputSource) {\n      throw new Error('No xrInputSource supplied');\n    }\n\n    if (!profile) {\n      throw new Error('No profile supplied');\n    }\n\n    this.xrInputSource = xrInputSource;\n    this.assetUrl = assetUrl;\n    this.id = profile.profileId;\n\n    // Build child components as described in the profile description\n    this.layoutDescription = profile.layouts[xrInputSource.handedness];\n    this.components = {};\n    Object.keys(this.layoutDescription.components).forEach((componentId) => {\n      const componentDescription = this.layoutDescription.components[componentId];\n      this.components[componentId] = new Component(componentId, componentDescription);\n    });\n\n    // Initialize components based on current gamepad state\n    this.updateFromGamepad();\n  }\n\n  get gripSpace() {\n    return this.xrInputSource.gripSpace;\n  }\n\n  get targetRaySpace() {\n    return this.xrInputSource.targetRaySpace;\n  }\n\n  /**\n   * @description Returns a subset of component data for simplified debugging\n   */\n  get data() {\n    const data = [];\n    Object.values(this.components).forEach((component) => {\n      data.push(component.data);\n    });\n    return data;\n  }\n\n  /**\n   * @description Poll for updated data based on current gamepad state\n   */\n  updateFromGamepad() {\n    Object.values(this.components).forEach((component) => {\n      component.updateFromGamepad(this.xrInputSource.gamepad);\n    });\n  }\n}\n\nexport { Constants, MotionController, fetchProfile, fetchProfilesList };\n","/* global THREE */\nconst {\n\tMesh,\n\tMeshBasicMaterial,\n\tObject3D,\n\tSphereGeometry,\n} = THREE;\n\nimport {\n\tConstants as MotionControllerConstants,\n\tfetchProfile,\n\tMotionController\n} from 'three/examples/jsm/libs/motion-controllers.module.js';\n\nconst DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';\nconst DEFAULT_PROFILE = 'generic-trigger';\n\nclass XRControllerModel extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.motionController = null;\n\t\tthis.envMap = null;\n\n\t}\n\n\tsetEnvironmentMap( envMap ) {\n\n\t\tif ( this.envMap == envMap ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.envMap = envMap;\n\t\tthis.traverse( ( child ) => {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tchild.material.envMap = this.envMap;\n\t\t\t\tchild.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Polls data from the XRInputSource and updates the model's components to match\n\t * the real world data\n\t */\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( ! this.motionController ) return;\n\n\t\t// Cause the MotionController to poll the Gamepad for data\n\t\tthis.motionController.updateFromGamepad();\n\n\t\t// Update the 3D model to reflect the button, thumbstick, and touchpad state\n\t\tObject.values( this.motionController.components ).forEach( ( component ) => {\n\n\t\t\t// Update node data based on the visual responses' current states\n\t\t\tObject.values( component.visualResponses ).forEach( ( visualResponse ) => {\n\n\t\t\t\tconst { valueNode, minNode, maxNode, value, valueNodeProperty } = visualResponse;\n\n\t\t\t\t// Skip if the visual response node is not found. No error is needed,\n\t\t\t\t// because it will have been reported at load time.\n\t\t\t\tif ( ! valueNode ) return;\n\n\t\t\t\t// Calculate the new properties based on the weight supplied\n\t\t\t\tif ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY ) {\n\n\t\t\t\t\tvalueNode.visible = value;\n\n\t\t\t\t} else if ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM ) {\n\n\t\t\t\t\tvalueNode.quaternion.slerpQuaternions(\n\t\t\t\t\t\tminNode.quaternion,\n\t\t\t\t\t\tmaxNode.quaternion,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t);\n\n\t\t\t\t\tvalueNode.position.lerpVectors(\n\t\t\t\t\t\tminNode.position,\n\t\t\t\t\t\tmaxNode.position,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Walks the model's tree to find the nodes needed to animate the components and\n * saves them to the motionContoller components for use in the frame loop. When\n * touchpads are found, attaches a touch dot to them.\n */\nfunction findNodes( motionController, scene ) {\n\n\t// Loop through the components and find the nodes needed for each components' visual responses\n\tObject.values( motionController.components ).forEach( ( component ) => {\n\n\t\tconst { type, touchPointNodeName, visualResponses } = component;\n\n\t\tif ( type === MotionControllerConstants.ComponentType.TOUCHPAD ) {\n\n\t\t\tcomponent.touchPointNode = scene.getObjectByName( touchPointNodeName );\n\t\t\tif ( component.touchPointNode ) {\n\n\t\t\t\t// Attach a touch dot to the touchpad.\n\t\t\t\tconst sphereGeometry = new SphereGeometry( 0.001 );\n\t\t\t\tconst material = new MeshBasicMaterial( { color: 0x0000FF } );\n\t\t\t\tconst sphere = new Mesh( sphereGeometry, material );\n\t\t\t\tcomponent.touchPointNode.add( sphere );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( `Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Loop through all the visual responses to be applied to this component\n\t\tObject.values( visualResponses ).forEach( ( visualResponse ) => {\n\n\t\t\tconst { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;\n\n\t\t\t// If animating a transform, find the two nodes to be interpolated between.\n\t\t\tif ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM ) {\n\n\t\t\t\tvisualResponse.minNode = scene.getObjectByName( minNodeName );\n\t\t\t\tvisualResponse.maxNode = scene.getObjectByName( maxNodeName );\n\n\t\t\t\t// If the extents cannot be found, skip this animation\n\t\t\t\tif ( ! visualResponse.minNode ) {\n\n\t\t\t\t\tconsole.warn( `Could not find ${minNodeName} in the model` );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! visualResponse.maxNode ) {\n\n\t\t\t\t\tconsole.warn( `Could not find ${maxNodeName} in the model` );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// If the target node cannot be found, skip this animation\n\t\t\tvisualResponse.valueNode = scene.getObjectByName( valueNodeName );\n\t\t\tif ( ! visualResponse.valueNode ) {\n\n\t\t\t\tconsole.warn( `Could not find ${valueNodeName} in the model` );\n\n\t\t\t}\n\n\t\t} );\n\n\t} );\n\n}\n\nfunction addAssetSceneToControllerModel( controllerModel, scene ) {\n\n\t// Find the nodes needed for animation and cache them on the motionController.\n\tfindNodes( controllerModel.motionController, scene );\n\n\t// Apply any environment map that the mesh already has set.\n\tif ( controllerModel.envMap ) {\n\n\t\tscene.traverse( ( child ) => {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tchild.material.envMap = controllerModel.envMap;\n\t\t\t\tchild.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// Add the glTF scene to the controllerModel.\n\tcontrollerModel.add( scene );\n\n}\n\nclass XRControllerModelFactory {\n\n\tconstructor( gltfLoader, onLoad = null ) {\n\n\t\tthis.gltfLoader = gltfLoader;\n\t\tthis.path = DEFAULT_PROFILES_PATH;\n\t\tthis._assetCache = {};\n\t\tthis.onLoad = onLoad;\n\n\t}\n\n\tsetPath( path ) {\n\n\t\tthis.path = path;\n\n\t\treturn this;\n\n\t}\n\n\tcreateControllerModel( controller ) {\n\n\t\tconst controllerModel = new XRControllerModel();\n\t\tlet scene = null;\n\t\tlet loading = false;\n\n\t\tcontroller.addEventListener( 'connected', ( event ) => {\n\n\t\t\tconst xrInputSource = event.data;\n\n\t\t\tif ( xrInputSource.targetRayMode !== 'tracked-pointer' || ! xrInputSource.gamepad || xrInputSource.hand ) return;\n\n\t\t\t// Guard against duplicate loading from multiple 'connected' events\n\t\t\tif ( loading ) return;\n\t\t\tloading = true;\n\n\t\t\tfetchProfile( xrInputSource, this.path, DEFAULT_PROFILE ).then( ( { profile, assetPath } ) => {\n\n\t\t\t\tcontrollerModel.motionController = new MotionController(\n\t\t\t\t\txrInputSource,\n\t\t\t\t\tprofile,\n\t\t\t\t\tassetPath\n\t\t\t\t);\n\n\t\t\t\tconst buttons = [];\n\t\t\t\tconst axes = [];\n\t\t\t\tconst gamepadMappings = { buttons, axes };\n\t\t\t\tcontrollerModel.gamepadMappings = gamepadMappings;\n\n\t\t\t\tif (controllerModel.motionController.layoutDescription?.components) {\n\t\t\t\t\tfor (let [name, details] of Object.entries(controllerModel.motionController.layoutDescription.components)) {\n\t\t\t\t\t\tname = name.replace('xr-standard-', '');\n\t\t\t\t\t\tfor (const [type, index] of Object.entries(details.gamepadIndices)) {\n\t\t\t\t\t\t\tif (type === 'button') {\n\t\t\t\t\t\t\t\tbuttons[index] = name;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\taxes[index] = {name,type};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst cachedAsset = this._assetCache[ controllerModel.motionController.assetUrl ];\n\t\t\t\tif ( cachedAsset ) {\n\n\t\t\t\t\tscene = cachedAsset.scene.clone();\n\n\t\t\t\t\taddAssetSceneToControllerModel( controllerModel, scene );\n\n\t\t\t\t\tif ( this.onLoad ) this.onLoad( scene );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ! this.gltfLoader ) {\n\n\t\t\t\t\t\tthrow new Error( 'GLTFLoader not set.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.gltfLoader.setPath( '' );\n\t\t\t\t\tthis.gltfLoader.load( controllerModel.motionController.assetUrl, ( asset ) => {\n\n\t\t\t\t\t\tthis._assetCache[ controllerModel.motionController.assetUrl ] = asset;\n\n\t\t\t\t\t\tscene = asset.scene.clone();\n\n\t\t\t\t\t\taddAssetSceneToControllerModel( controllerModel, scene );\n\n\t\t\t\t\t\tif ( this.onLoad ) this.onLoad( scene );\n\n\t\t\t\t\t},\n\t\t\t\t\tnull,\n\t\t\t\t\t() => {\n\n\t\t\t\t\t\tthrow new Error( `Asset ${controllerModel.motionController.assetUrl} missing or malformed.` );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} ).catch( ( err ) => {\n\n\t\t\t\tconsole.warn( err );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tcontroller.addEventListener( 'disconnected', () => {\n\n\t\t\tcontrollerModel.motionController = null;\n\t\t\tcontrollerModel.remove( scene );\n\t\t\tscene = null;\n\t\t\tloading = false;\n\n\t\t} );\n\n\t\treturn controllerModel;\n\n\t}\n\n}\n\nexport { XRControllerModelFactory };\n","/* global AFRAME, THREE */\nimport { XRControllerModelFactory } from './lib/XRControllerModelFactory.js';\nconst __version__ = __version__;\nconst DEFAULT_PROFILES_PATH = \"https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles\";\nconst DEFAULT_HAND_PROFILE_PATH = DEFAULT_PROFILES_PATH + \"/generic-hand\";\nconst LIB_URL = \"https://cdn.jsdelivr.net/npm/handy-work\" + (__version__ ? '@' + __version__ : '');\nconst LIB = LIB_URL + \"/build/esm/handy-work.standalone.js\";\nconst POSE_FOLDER = LIB_URL + \"/poses/\";\nconst clamp = (a, min = 0, max = 1) => Math.min(max, Math.max(min, a));\nconst invlerp = (x, y, a) => clamp((a - x) / (y - x));\nconst prevGamePads = new Map();\nconst changedAxes = new Set();\n\nconst tempVector3_A = new THREE.Vector3();\nconst tempVector3_B = new THREE.Vector3();\nconst tempQuaternion_A = new THREE.Quaternion();\nconst tempQuaternion_B = new THREE.Quaternion();\nconst tempQuaternion_C = new THREE.Quaternion();\nconst handednesses = ['left', 'right', 'none'];\n\nconst joints = [\n  \"wrist\",\n  \"thumb-metacarpal\",\n  \"thumb-phalanx-proximal\",\n  \"thumb-phalanx-distal\",\n  \"thumb-tip\",\n  \"index-finger-metacarpal\",\n  \"index-finger-phalanx-proximal\",\n  \"index-finger-phalanx-intermediate\",\n  \"index-finger-phalanx-distal\",\n  \"index-finger-tip\",\n  \"middle-finger-metacarpal\",\n  \"middle-finger-phalanx-proximal\",\n  \"middle-finger-phalanx-intermediate\",\n  \"middle-finger-phalanx-distal\",\n  \"middle-finger-tip\",\n  \"ring-finger-metacarpal\",\n  \"ring-finger-phalanx-proximal\",\n  \"ring-finger-phalanx-intermediate\",\n  \"ring-finger-phalanx-distal\",\n  \"ring-finger-tip\",\n  \"pinky-finger-metacarpal\",\n  \"pinky-finger-phalanx-proximal\",\n  \"pinky-finger-phalanx-intermediate\",\n  \"pinky-finger-phalanx-distal\",\n  \"pinky-finger-tip\",\n];\n\nAFRAME.registerComponent(\"handy-controls\", {\n  schema: {\n    renderGamepad: {\n      oneOf: ['any', 'left', 'right', 'none', 'never'],\n      default: 'any',\n      description: `Whether to render a gamepad model when it's not doing hand tracking, right, none and left are the names of controller handedness, any is all of them, and never is to not draw gamepads`\n    },\n    left: {\n      description: 'URL for left controller',\n      type: 'model',\n      default: DEFAULT_HAND_PROFILE_PATH + \"/left.glb\",\n    },\n    right: {\n      description: 'URL for right controller',\n      type: 'model',\n      default: DEFAULT_HAND_PROFILE_PATH + \"/right.glb\",\n    },\n    materialOverride: {\n      description: 'Which hand to use the `material` component for',\n      oneOf: ['both', 'left', 'right', 'neither'],\n      default: 'both'\n    },\n    fuseVShort: {\n      description: 'Time for a pose to trigger a pose event (ms)',\n      default:48\n    },\n    fuseShort: {\n      description: 'Time for a pose to trigger a pose_fuseShort event (ms)',\n      default:480\n    },\n    fuseLong: {\n      description: 'Time for a pose to trigger a pose_fuseLong event (ms)',\n      default:1440\n    }\n  },\n  init() {\n    const sceneEl = this.el.sceneEl;\n    const webxrData = this.el.sceneEl.getAttribute('webxr');\n    const optionalFeaturesArray = webxrData.optionalFeatures;\n    if (!optionalFeaturesArray.includes('hand-tracking')) {\n      optionalFeaturesArray.push('hand-tracking');\n      this.el.sceneEl.setAttribute('webxr', webxrData);\n    }\n    \n    this.loader = new THREE.GLTFLoader();\n    const self = this;\n    const dracoLoader = this.el.sceneEl.systems['gltf-model'].getDRACOLoader();\n    const meshoptDecoder = this.el.sceneEl.systems['gltf-model'].getMeshoptDecoder();\n    this.controllerModelFactory = new XRControllerModelFactory(this.loader);\n    this.controllerModelFactory.setPath(DEFAULT_PROFILES_PATH);\n    this.model = null;\n    if (dracoLoader) {\n      this.loader.setDRACOLoader(dracoLoader);\n    }\n    if (meshoptDecoder) {\n      this.ready = meshoptDecoder.then(function (meshoptDecoder) {\n        self.loader.setMeshoptDecoder(meshoptDecoder);\n      });\n    } else {\n      this.ready = Promise.resolve();\n    }\n    \n    import(LIB)\n    .then(function ({\n      update,\n      loadPose,\n      dumpHands,\n      setPose,\n      getPose\n    }) {\n      this.handyWorkUpdate = update;\n      this.dumpHands = dumpHands;\n      this.loadPose = loadPose;\n      this.setPose = setPose;\n      this.getPose = getPose;\n\n      loadPose('relax', POSE_FOLDER + 'relax.handpose');\n      loadPose('fist', POSE_FOLDER + 'fist.handpose');\n      loadPose('flat', POSE_FOLDER + 'flat.handpose');\n      loadPose('point', POSE_FOLDER + 'point.handpose');\n      loadPose('horns', POSE_FOLDER + 'horns.handpose');\n      loadPose('shaka', POSE_FOLDER + 'shaka.handpose');\n      loadPose('vulcan', POSE_FOLDER + 'vulcan.handpose');\n    }.bind(this));\n    \n    for (const handedness of handednesses) {\n      const els = Array.from(this.el.querySelectorAll(`[data-${handedness}]`));\n      for (const el of els) {\n        el.object3D.visible = false;\n      }\n    }\n\n    sceneEl.addEventListener(\"enter-vr\", () => {\n      for (const name of [\"select\", \"selectstart\", \"selectend\", \"squeeze\", \"squeezeend\", \"squeezestart\"])\n        sceneEl.xrSession.addEventListener(name, this.eventFactory(name, this));\n    });\n\n    this.elArrays = { left: [], right: [], none: [] };\n    this.elMaps = { left: new Map(), right: new Map(), none: new Map() };\n    this.magnetEls = new Map();\n    this.magnetTargets = new Map();\n\n    function reconstructElMaps() {\n      for (const handedness of handednesses) {\n        self.elArrays[handedness].splice(0);\n        self.elMaps[handedness].clear();\n        self.magnetEls.clear();\n        self.magnetTargets.clear();\n      }\n\n      const els = Array.from(self.el.children).filter(el=>el.dataset.left||el.dataset.right||el.dataset.none);\n      for (const el of els) {\n        for (const handedness of handednesses) {\n          if (el.dataset[handedness] !== undefined) {\n            self.elArrays[handedness].push(el);\n            const poseName = el.dataset[handedness];\n            const poseElArray = self.elMaps[handedness].get(poseName) || [];\n            poseElArray.push(el);\n            self.elMaps[handedness].set(poseName, poseElArray);\n\n            if (el.dataset.magnet) {\n              self.magnetEls.set(handedness, el);\n              self.magnetTargets.set(el, null);\n            }\n          }\n        }\n      }\n    }\n    reconstructElMaps();\n    // if the children of this element change then rebuild the lists\n    new MutationObserver(reconstructElMaps).observe(this.el, { childList: true });\n    // If any of the hands change position rebuild it\n    new MutationObserver(function (changes) {\n      if (changes.find(change => (\n        change.attributeName === 'data-none' ||\n        change.attributeName === 'data-left' ||\n        change.attributeName === 'data-right' ||\n        change.attributeName === 'data-magnet'\n      ))) reconstructElMaps();\n    }).observe(this.el, { attributes: true, subtree: true });\n  },\n\n  getMagnetTargets(el) {\n    const magnetTargets = this.magnetTargets.get(el);\n    if (magnetTargets === null) {\n      const magnetTargets = document.getElementsByClassName(el.dataset.magnet);\n      this.magnetTargets.set(el, magnetTargets);\n      return magnetTargets;\n    }\n    return magnetTargets;\n  },\n\n  async gltfToJoints(src, name) {\n    const el = this.el;\n    await this.ready;\n\n    const gltf = await new Promise(function (resolve, reject) {\n      this.loader.load(src, resolve, undefined, reject);\n    }.bind(this));\n\n    const object = gltf.scene.children[0];\n    const mesh = object.getObjectByProperty(\"type\", \"SkinnedMesh\");\n    \n    if (this.el.components.material) {\n      if (this.data.materialOverride === 'both' || this.data.materialOverride === name) {\n        mesh.material = this.el.components.material.material;\n      }\n    }\n    \n    mesh.visible = false;\n    mesh.frustumCulled = false;\n    mesh.castShadow = true;\n    mesh.receiveShadow = true;\n    mesh.skeleton.pose();\n    \n    const bones = [];\n    for (const jointName of joints) {\n      const bone = object.getObjectByName(jointName);\n      if (bone !== undefined) {\n        bone.jointName = jointName;\n        bones.push(bone);\n        bone.applyMatrix4(this.el.object3D.matrixWorld);\n        bone.updateMatrixWorld();\n      } else {\n        console.warn(`Couldn't find ${jointName} in ${src} hand mesh`);\n        bones.push(undefined); // add an empty slot\n      }\n    }\n    el.setObject3D('hand-mesh-' + name, mesh);\n    el.emit(\"model-loaded\", { format: \"gltf\", model: mesh });\n    return bones;\n  },\n\n  async update(oldData) {\n    const el = this.el;\n    const srcLeft = this.data.left;\n    const srcRight = this.data.right;\n\n    // Only reload models if they changed\n    if (\n      oldData.left !== this.data.left ||\n      oldData.right !== this.data.right ||\n      oldData.renderGamepad !== this.data.renderGamepad\n    ) {\n      this.remove();\n    }\n    if (oldData.left !== this.data.left || oldData.right !== this.data.right) {\n      try {\n        this.bonesRight = await this.gltfToJoints(srcRight, \"right\");\n        this.bonesLeft = await this.gltfToJoints(srcLeft, \"left\");\n      } catch (error) {\n        const message = error && error.message ? error.message : \"Failed to load glTF model\";\n        console.warn(message);\n        el.emit(\"hand-model-error\", { message });\n      }\n    }\n  },\n\n  eventFactory(eventName, bindTarget, event) {\n    function eventHandler(e) {\n      const session = this.el.sceneEl.xrSession;\n      const frame = e.frame;\n      const inputSource = e.inputSource;\n      const referenceSpace = this.el.sceneEl.renderer.xr.getReferenceSpace();\n      const pose = frame.getPose(inputSource.targetRaySpace, referenceSpace);\n      const handedness = e.inputSource.handedness;\n      const details = {\n        inputSource,\n        handedness,\n        frame\n      }\n      if (!pose) return;\n\n      const allEls = this.elArrays[handedness];\n      if (inputSource.targetRayMode === \"screen\") {\n        const name = `screen-${\n          Array.from(session.inputSources).filter(i=>i.targetRayMode === \"screen\").indexOf(inputSource)\n        }`;\n        for (const el of allEls) {\n          if (el.dataset[handedness] === name) {\n            el.object3D.position.copy(pose.transform.position);\n            el.object3D.quaternion.copy(pose.transform.orientation);\n            el.object3D.visible = (el.getDOMAttribute('visible') !== false);\n            el.emit(eventName, details);\n          }\n        }\n      } else if (inputSource.gamepad || inputSource.hand) {\n        for (const el of allEls) el.emit(eventName, details);\n      }\n    }\n    if (event) return eventHandler.call(bindTarget, event);\n    return eventHandler.bind(bindTarget);\n  },\n\n  initControllerModels() {\n    if (this.controllerModelsInitialized) return;\n    this.controllerModelsInitialized = true;\n\n    const renderer = this.el.sceneEl.renderer;\n    for (let i = 0; i < 2; i++) {\n      const controllerGrip = renderer.xr.getControllerGrip(i);\n      const model = this.controllerModelFactory.createControllerModel(controllerGrip);\n      model.userData.controllerGrip = controllerGrip;\n      model.visible = false;\n\n      // Track which handedness the controllerGrip is currently controlling.\n      // This is set by WebXRManager's 'connected' events.\n      controllerGrip.addEventListener('connected', (event) => {\n        const xrInputSource = event.data;\n        model.userData.handedness = xrInputSource.handedness;\n      });\n      controllerGrip.addEventListener('disconnected', () => {\n        model.userData.handedness = 'unknown';\n        model.visible = false;\n      });\n\n      this.el.setObject3D('controller-model-' + i, model);\n    }\n  },\n\n  getControllerModel(inputSource) {\n    this.initControllerModels();\n\n    const model0 = this.el.getObject3D('controller-model-0');\n    const model1 = this.el.getObject3D('controller-model-1');\n\n    // Find model with matching handedness\n    let model = null;\n    if (model0.userData.handedness === inputSource.handedness) {\n      model = model0;\n    } else if (model1.userData.handedness === inputSource.handedness) {\n      model = model1;\n    }\n\n    // If no model matches, 'connected' events may not have fired yet.\n    // Find an available model (handedness unknown or undefined) and use it.\n    if (!model) {\n      if (!model0.userData.handedness || model0.userData.handedness === 'unknown') {\n        model = model0;\n        model.userData.handedness = inputSource.handedness;\n      } else if (!model1.userData.handedness || model1.userData.handedness === 'unknown') {\n        model = model1;\n        model.userData.handedness = inputSource.handedness;\n      }\n    }\n\n    if (model) {\n      // If no motionController yet, dispatch 'connected' to trigger model loading.\n      // This handles the case where WebXRManager's 'connected' fired while hand\n      // tracking was active (factory ignores events with .hand).\n      // The factory guards against duplicate loads internally.\n      if (!model.motionController && model.userData.controllerGrip) {\n        model.userData.controllerGrip.dispatchEvent({ type: 'connected', data: inputSource });\n      }\n      model.visible = true;\n      return model;\n    }\n\n    return null;\n  },\n\n  tick() {\n    const self = this;\n    const session = this.el.sceneEl.xrSession;\n    if (!session) return;\n    const renderer = this.el.sceneEl.renderer;\n    const referenceSpace = renderer.xr.getReferenceSpace();\n    const toUpdate = [];\n    const frame = this.el.sceneEl.frame;\n    if (!frame) return;\n\n    let transientSourceIndex = 0;\n    inputSourceLoop:\n    for (const inputSource of session.inputSources) {\n      const magnetEl = this.magnetEls.get(inputSource.handedness);\n      let magnetTarget = null;\n      let fadeT = 1;\n      let bones = [];\n      const toMagnet = [];\n      let handMesh;\n      \n      const allEls = this.elArrays[inputSource.handedness];\n      const elMap = this.elMaps[inputSource.handedness];\n\n      handMesh = this.el.getObject3D(\"hand-mesh-\" + inputSource.handedness);\n      if (inputSource.hand) {\n        toUpdate.push(inputSource);\n\n        // Hide controller model when hand tracking is active\n        const model0 = this.el.getObject3D('controller-model-0');\n        const model1 = this.el.getObject3D('controller-model-1');\n        if (model0 && model0.userData.handedness === inputSource.handedness) {\n          model0.visible = false;\n        }\n        if (model1 && model1.userData.handedness === inputSource.handedness) {\n          model1.visible = false;\n        }\n\n        bones =\n          (inputSource.handedness === \"right\" && this.bonesRight) ||\n          (inputSource.handedness === \"left\" && this.bonesLeft);\n        if (!bones.length) continue;\n        let hadAJointPose = false;\n        for (const bone of bones) {\n          const joint = inputSource.hand.get(bone.jointName);\n          toMagnet.push(bone);\n          if (joint) {\n\n            const pose = frame.getJointPose(joint, referenceSpace);\n            if (pose) {\n              hadAJointPose = true;\n\n              // if there are objects make them visible and set their position\n              if (elMap.has(bone.jointName)) {\n\n                if (handMesh.visible === false) {\n                  for (const el of elMap.get(bone.jointName)) {\n                    el.object3D.visible = (el.getDOMAttribute('visible') !== false);\n                  }\n                }\n\n                for (const el of elMap.get(bone.jointName)) {\n                  el.object3D.position.copy(pose.transform.position);\n                  el.object3D.quaternion.copy(pose.transform.orientation);\n                  if (el.dataset.noMagnet === undefined) toMagnet.push(el.object3D);\n                }\n              }\n              \n              bone.position.copy(pose.transform.position);\n              bone.quaternion.copy(pose.transform.orientation);\n            } else {\n              // Failed to get hand pose so continue looping over other inputSource\n              continue inputSourceLoop;\n            }\n          }\n        }\n        if (hadAJointPose) {\n          handMesh.visible = true;\n        }\n      } else if (handMesh)  {\n        handMesh.visible = false;\n\n        for (const el of allEls){\n          el.object3D.visible = false;\n        }\n      }\n\n      if (inputSource.targetRayMode === \"screen\") {\n        const name = `screen-${transientSourceIndex++}`;\n        if (elMap.has(name)) {\n          const pose = frame.getPose(inputSource.targetRaySpace, referenceSpace);\n          if (!pose) continue inputSourceLoop;\n          for (const el of elMap.get(name)) {\n            el.object3D.position.copy(pose.transform.position);\n            el.object3D.quaternion.copy(pose.transform.orientation);\n            el.object3D.visible = (el.getDOMAttribute('visible') !== false);\n          }\n        }\n\n        // Don't do the magnet behaviour and don't render any gamepads\n        continue inputSourceLoop;\n      }\n\n      // handle any tracked elements attached to the ray space of the input source this works for any types\n      for (const [name, inputSourcePose] of [\n        ['ray', inputSource.targetRaySpace],\n        ['grip', inputSource.gripSpace]\n      ]) {\n        if (elMap.has(name) && inputSourcePose) {\n          const pose = frame.getPose(inputSourcePose, referenceSpace);\n          if (pose) {\n            for (const el of elMap.get(name)) {\n              el.object3D.position.copy(pose.transform.position);\n              el.object3D.quaternion.copy(pose.transform.orientation);\n              const elShouldBeVisible = (el.getDOMAttribute('visible') !== false)\n              el.object3D.visible = elShouldBeVisible;\n              if (el.dataset.noMagnet === undefined) toMagnet.push(el.object3D);\n            }\n          }\n        }\n      }\n\n      // If we should draw gamepads then do, but don't draw gamepad and hand if btoh present\n      if (\n        (this.data.renderGamepad === \"any\" || this.data.renderGamepad === inputSource.handedness) &&\n        inputSource.gamepad && !inputSource.hand\n      ) {\n        const controllerModel = this.getControllerModel(inputSource);\n        if (controllerModel) {\n          if (inputSource.gripSpace) {\n            const pose = frame.getPose(inputSource.gripSpace, referenceSpace);\n            if (pose) {\n              controllerModel.position.copy(pose.transform.position);\n              controllerModel.quaternion.copy(pose.transform.orientation);\n              toMagnet.push(controllerModel);\n            }\n          }\n\n          // if it has a gamepad fire events for gamepad changes\n          const old = prevGamePads.get(inputSource);\n          const data = {\n            buttons: inputSource.gamepad.buttons.map(b => b.value),\n            axes: inputSource.gamepad.axes.slice(0)\n          };\n          if (old) {\n            const eventDetails = {handedness: inputSource.handedness, inputSource, data, frame}\n            data.buttons.forEach((value,i)=>{\n              if (value !== old.buttons[i]) {\n                let name = controllerModel.gamepadMappings?.buttons[i] || `button${i}`;\n                if (value === 1) {\n                  this.emitGamepad(allEls, `${name}down`, Object.assign({value}, eventDetails));\n                } else {\n                  this.emitGamepad(allEls, `${name}up`, Object.assign({value}, eventDetails));\n                }\n              }\n            });\n            const axesMapping = controllerModel.gamepadMappings?.axes;\n            if (axesMapping && axesMapping.length) {\n              // There are some named axis so try to combine them together\n              changedAxes.clear();\n              const details =  {};\n              axesMapping.forEach(({name}, i)=>{\n                if (name) {\n                  const value = data.axes[i];\n                  if (value !== old.axes[i]) {\n                    changedAxes.add(name);\n                  }\n                }\n              });\n              if (changedAxes.size) {\n                axesMapping.forEach(({name, type}, i)=>{\n                  if (name && changedAxes.has(name)) {\n                    const value = data.axes[i];\n                    details[name] =  details[name] || {};\n                    details[name][type.slice(0,1)] = value;\n                  }\n                });\n                for (const [name, detail] of Object.entries(details)) {\n                  this.emitGamepad(allEls, `${name}moved`, Object.assign(detail, eventDetails));\n                }\n              }\n            } else {\n              data.axes.forEach((value,i)=>{\n                let name = controllerModel.gamepadMappings?.axes[i] || `axes${i}`;\n                if (value !== old.axes[i]) {\n                  this.emitGamepad(allEls, `${name}moved`, Object.assign({value}, eventDetails));\n                }\n              });\n            }\n          }\n          prevGamePads.set(inputSource, data);\n        }\n      }\n      \n      if (magnetEl) {\n        this.el.object3D.getWorldQuaternion(tempQuaternion_C).invert();\n        magnetEl.object3D.getWorldPosition(tempVector3_A);\n        for (const el of this.getMagnetTargets(magnetEl)) {\n          let magnetRange,fadeEnd,angleRange,angleEnd;\n          const magnetRangeData = el.dataset.magnetRange;\n          if (magnetRangeData) {\n            if (el.object3D.userData.magnetRangeData) {\n              [magnetRange,fadeEnd,angleRange,angleEnd] = el.object3D.userData.magnetRangeData;\n            } else {\n              // Cache it\n              el.object3D.userData.magnetRangeData = magnetRangeData.split(',').map(n => Number(n));\n              [magnetRange,fadeEnd,angleRange,angleEnd] = el.object3D.userData.magnetRangeData;\n            }\n          }\n          magnetRange = magnetRange || 0.2;\n          fadeEnd = fadeEnd === undefined ? 0.1 : fadeEnd;\n          angleRange = angleRange || 120;\n          angleEnd = angleEnd === undefined ? 80 : angleEnd;\n          const d =  el.object3D.getWorldPosition(tempVector3_B).sub(tempVector3_A).length();\n          if (d < magnetRange) {\n            const Θ = (180/Math.PI) * el.object3D.getWorldQuaternion(tempQuaternion_A).premultiply(tempQuaternion_C).angleTo(magnetEl.object3D.quaternion);\n            if (Θ < angleRange) {\n              magnetTarget = el;\n              fadeT = invlerp(magnetRange,fadeEnd,d) * invlerp(angleRange,angleEnd,Θ);\n              break;\n            }\n          }\n        }\n\n        if (fadeT > 0.2 && magnetTarget && magnetTarget.id) {\n          magnetEl.dataset.magnetTarget = magnetTarget.id;\n        } else {\n          delete magnetEl.dataset.magnetTarget;\n        }\n      }\n      \n      if (magnetTarget) {\n\n        this.el.object3D.worldToLocal(magnetTarget.object3D.getWorldPosition(tempVector3_A));\n        tempVector3_B.copy(magnetEl.object3D.position);\n        tempVector3_A.lerp(tempVector3_B, 1-fadeT).sub(tempVector3_B);\n        \n        // tempQuaternion_A is populated already when calculating if it's a close enough angle\n        // magnetTarget.object3D.getWorldQuaternion(tempQuaternion_A);\n        // tempQuaternion_A.premultiply(tempQuaternion_C);\n        tempQuaternion_B.copy(magnetEl.object3D.quaternion);\n        tempQuaternion_A.slerp(tempQuaternion_B, 1-fadeT).multiply(tempQuaternion_B.invert());\n        \n        // Move elements to match the bones but skil elements which are marked data-no-magnet\n        for (const object3D of toMagnet) {\n          object3D.position.sub(tempVector3_B);\n          object3D.position.applyQuaternion(tempQuaternion_A);\n          object3D.position.add(tempVector3_B);\n          object3D.applyQuaternion(tempQuaternion_A);\n          object3D.position.add(tempVector3_A);\n        }\n      }\n      for (const bone of bones) {\n        bone.applyMatrix4(this.el.object3D.matrixWorld);\n        bone.updateMatrixWorld();\n      }\n    }\n\n    // perform hand pose detection\n    if (toUpdate.length && this.handyWorkUpdate) {\n      this.handyWorkUpdate(\n        toUpdate,\n        referenceSpace,\n        frame,\n        function ({\n          distances, handedness\n        }) {\n          self.emitHandpose(distances[0][0], handedness, {\n            pose: distances[0][0],\n            poses: distances,\n            handedness,\n            frame\n          });\n        }\n      );\n    }\n  },\n  emitGamepad (els, name, details) {\n    details.event = name;\n    for (const el of els) {\n      el.emit(name, details, false);\n      el.emit('gamepad', details, false);\n    }\n  },\n  emitHandpose(name, handedness, details) {\n    const oldPoseName = this[handedness + '_currentPose'];\n    if (name === oldPoseName) return;\n    const els = this.elArrays[handedness];\n    \n    clearTimeout(this[handedness + '_vshortTimeout']);\n    clearTimeout(this[handedness + '_shortTimeout']);\n    clearTimeout(this[handedness + '_longTimeout']);\n\n    // This just fires cancel if it's no longer at the top but maybe be smarter?\n    if (oldPoseName) {\n      const oldPoseDetails = Object.assign({}, details);\n      oldPoseDetails.pose = oldPoseName;\n      for (const el of els) {\n        el.emit('pose_cancel_' + oldPoseName, oldPoseDetails, false);\n        el.emit('pose_end', oldPoseDetails, false);\n      }\n    }\n    \n    this[handedness + '_currentPose'] = name;\n\n    this[handedness + '_vshortTimeout'] = setTimeout(() => {\n      for (const el of els) {\n        el.emit('pose_' + name, details, false);\n        el.emit('pose', details, false);\n      }\n    }, this.data.fuseVShort);\n    \n    this[handedness + '_shortTimeout'] = setTimeout(() => {\n      for (const el of els) el.emit('pose_' + name + '_fuseShort', details, false);\n    }, this.data.fuseShort);\n    \n    this[handedness + '_longTimeout'] = setTimeout(() => { \n      for (const el of els) el.emit('pose_' + name + '_fuseLong', details, false);\n    }, this.data.fuseLong);\n  },\n  remove() {\n    if (this.bonesLeft) {\n      this.bonesLeft = null;\n      this.el.removeObject3D(\"hand-mesh-left\");\n    }\n    if (this.bonesRight) {\n      this.bonesRight = null;\n      this.el.removeObject3D(\"hand-mesh-right\");\n    }\n    if (this.el.getObject3D('controller-model-0')) this.el.removeObject3D('controller-model-0');\n    if (this.el.getObject3D('controller-model-1')) this.el.removeObject3D('controller-model-1');\n    this.controllerModelsInitialized = false;\n  },\n});\n"],"names":["Constants","Handedness","Object","freeze","NONE","LEFT","RIGHT","ComponentState","DEFAULT","TOUCHED","PRESSED","ComponentProperty","BUTTON","X_AXIS","Y_AXIS","STATE","ComponentType","TRIGGER","SQUEEZE","TOUCHPAD","THUMBSTICK","ButtonTouchThreshold","AxisTouchThreshold","VisualResponseProperty","TRANSFORM","VISIBILITY","async","fetchJsonFile","path","response","fetch","ok","json","Error","statusText","fetchProfile","xrInputSource","basePath","defaultProfile","getAssetPath","supportedProfilesList","fetchProfilesList","match","profiles","some","profileId","supportedProfile","profilePath","deprecated","profile","assetPath","layout","handedness","layouts","keys","replace","defaultComponentValues","xAxis","yAxis","button","state","VisualResponse","constructor","visualResponseDescription","this","componentProperty","states","valueNodeName","valueNodeProperty","minNodeName","maxNodeName","value","updateFromComponent","normalizedXAxis","normalizedYAxis","x","y","Math","sqrt","theta","atan2","cos","sin","normalizeAxes","includes","Component","componentId","componentDescription","visualResponses","gamepadIndices","length","id","type","rootNodeName","touchPointNodeName","forEach","responseName","visualResponse","assign","values","undefined","data","updateFromGamepad","gamepad","buttons","gamepadButton","pressed","touched","axes","abs","MotionController","assetUrl","layoutDescription","components","gripSpace","targetRaySpace","component","push","Mesh","MeshBasicMaterial","Object3D","SphereGeometry","THREE","XRControllerModel","super","motionController","envMap","setEnvironmentMap","traverse","child","isMesh","material","needsUpdate","updateMatrixWorld","force","valueNode","minNode","maxNode","MotionControllerConstants","visible","quaternion","slerpQuaternions","position","lerpVectors","addAssetSceneToControllerModel","controllerModel","scene","touchPointNode","getObjectByName","sphereGeometry","color","sphere","add","findNodes","XRControllerModelFactory","gltfLoader","onLoad","_assetCache","setPath","createControllerModel","controller","loading","addEventListener","event","targetRayMode","hand","then","gamepadMappings","name","details","entries","index","cachedAsset","clone","load","asset","catch","err","remove","DEFAULT_PROFILES_PATH","DEFAULT_HAND_PROFILE_PATH","LIB_URL","LIB","POSE_FOLDER","invlerp","a","min","max","clamp","prevGamePads","Map","changedAxes","Set","tempVector3_A","Vector3","tempVector3_B","tempQuaternion_A","Quaternion","tempQuaternion_B","tempQuaternion_C","handednesses","joints","AFRAME","registerComponent","schema","renderGamepad","oneOf","default","description","left","right","materialOverride","fuseVShort","fuseShort","fuseLong","init","sceneEl","el","webxrData","getAttribute","optionalFeaturesArray","optionalFeatures","setAttribute","loader","GLTFLoader","self","dracoLoader","systems","getDRACOLoader","meshoptDecoder","getMeshoptDecoder","controllerModelFactory","model","setDRACOLoader","ready","setMeshoptDecoder","Promise","resolve","import","update","loadPose","dumpHands","setPose","getPose","handyWorkUpdate","bind","els","Array","from","querySelectorAll","object3D","reconstructElMaps","elArrays","splice","elMaps","clear","magnetEls","magnetTargets","children","filter","dataset","none","poseName","poseElArray","get","set","magnet","xrSession","eventFactory","MutationObserver","observe","childList","changes","find","change","attributeName","attributes","subtree","getMagnetTargets","document","getElementsByClassName","src","object","reject","mesh","getObjectByProperty","frustumCulled","castShadow","receiveShadow","skeleton","pose","bones","jointName","bone","applyMatrix4","matrixWorld","setObject3D","emit","format","oldData","srcLeft","srcRight","bonesRight","gltfToJoints","bonesLeft","error","message","eventName","bindTarget","eventHandler","e","session","frame","inputSource","referenceSpace","renderer","xr","getReferenceSpace","allEls","inputSources","i","indexOf","copy","transform","orientation","getDOMAttribute","call","initControllerModels","controllerModelsInitialized","controllerGrip","getControllerGrip","userData","getControllerModel","model0","getObject3D","model1","dispatchEvent","tick","toUpdate","transientSourceIndex","inputSourceLoop","magnetEl","magnetTarget","fadeT","toMagnet","handMesh","elMap","hadAJointPose","joint","getJointPose","has","noMagnet","inputSourcePose","elShouldBeVisible","old","map","b","slice","eventDetails","emitGamepad","axesMapping","size","detail","getWorldQuaternion","invert","getWorldPosition","magnetRange","fadeEnd","angleRange","angleEnd","magnetRangeData","split","n","Number","d","sub","PI","premultiply","angleTo","worldToLocal","lerp","slerp","multiply","applyQuaternion","distances","emitHandpose","poses","oldPoseName","clearTimeout","oldPoseDetails","setTimeout","removeObject3D"],"mappings":"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"}