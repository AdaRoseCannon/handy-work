{"version":3,"file":"handy-work.js","sources":["../../src/handy-work.js","../../comlink:/home/vincentfretin/workspace/handy-work/src/handpose.js","../../omt:/home/vincentfretin/workspace/handy-work/src/handpose.js?comlink"],"sourcesContent":["/**\n * Documentation for using build/esm/handy-work.js or build/esm/handy-work.standalone.js\n * @module handy-work\n */\n\nimport {transfer} from 'comlink'; \nimport normalize from './normalize.js';\n\nimport {default as comlinkHandPose} from \"comlink:./handpose.js\";\nconst HandPose = comlinkHandPose.default;\n\n/**\n * Loads a pose from the Web the recommended way of using this API\n * @param {string} name Name of the pose\n * @param {string} url URL of the pose to download and add to the registry\n * @returns {Promise<void>} Resolves once it has been completed\n */\nexport function loadPose(name, url) {\n\treturn HandPose.loadPose(name, url);\n}\n\n/**\n * Get a pose from the registry\n * @param {string} name of the pose to fetch\n * @returns {Promise<Float32Array>} A copy of the pose from the registry in the worker\n */\nexport function getPose(name) {\n\treturn HandPose.getPose(name);\n}\n\n/**\n * Get a pose from the registry\n * @param {string} name of the pose to set\n * @param {Float32Array} pose Array buffer with the information about the current pose\n * @returns {Promise<void>} Resolves once the pose has been uploaded to the worker\n */\nexport function setPose(name, pose) {\n\treturn HandPose.setPose(name, pose);\n}\n\n// Add event listeners\nlet listenersLoaded = false;\nwindow.addEventListener('enter-vr', resetHands);\nwindow.addEventListener('exit-vr', resetHands);\n\nconst handPoses = new EventTarget();\n\nclass HandInfo {\n\t#ready\n\n\tconstructor({\n\t\tsource, handPose\n\t}) {\n\t\tthis.handPose = handPose;\n\t\tthis.size = source.hand.size;\n\t\tthis.jointKeys = Array.from(source.hand.keys());\n\t\tthis.hand = source.hand;\n\t\tthis.jointMatrixArray = new Float32Array(source.hand.size * 16);\n\t\tthis.handedness = source.handedness;\n\n\t\tif (!listenersLoaded) {\n\t\t\tlistenersLoaded = true;\n\t\t}\n\t\tthis.#ready = true;\n\t}\n\n\tasync update(xrViewerPose, referenceSpace, frame) {\n\t\tif (!this.#ready) {\n\t\t\t// console.warn('Pose detection taking too long');\n\t\t\treturn [];\n\t\t}\n\n\t\t// transfer the pose array buffer to the thread, we now cannot do anything until it returns so mark it as not ready\n\t\tthis.#ready = false;\n\t\tframe.fillPoses( this.hand.values() , referenceSpace, this.jointMatrixArray );\n\t\tconst returnData = await this.handPose.update(\n\t\t\txrViewerPose.transform.matrix,\n\t\t\ttransfer(this.jointMatrixArray, [this.jointMatrixArray.buffer]),\n\t\t\tthis.handedness\n\t\t);\n\t\tthis.jointMatrixArray = returnData.usedHandArrayBuffer;\n\t\tthis.#ready = true;\n\t\treturn returnData.distances;\n\t}\n}\nconst hands = new Map();\n\n/**\n * Reset the current tracking performed automatically when the device returns from sleep\n */\nexport function resetHands() {\n\thands.clear();\n}\n\nlet __dumphands = false;\n\n/**\n * On the next frame save the current hand pose to a file\n */\nexport function dumpHands() {\n\t__dumphands = true;\t\n}\n\n/**\n * Get a pose from the current hand position\n * @param {XRInputSource} inputSources Array of inputs you want to generate inputs for, requires a left AND right hand\n * @param {XRReferenceSpace} referenceSpace Current reference space\n * @param {XRFrame} frame Current active frame\n * @returns {void|Float32Array} The generated pose buffer for the pose.\n */\nexport function generatePose(inputSources, referenceSpace, frame, float32Array) {\n\tconst tempHands = {};\n\n\tfor (const source of inputSources) {\n\t\tif (!source.hand) continue;\n\t\ttempHands[source.handedness] = source.hand;\n\t}\n\tif (tempHands.left && tempHands.right) {\n\n\t\tconst size = tempHands.left.size;\n\t\tconst bufferSize = \n\t\t\t1 +         // store size\n\t\t\tsize * 16 + // left hand\n\t\t\tsize * 16 + // right hand\n\t\t\tsize +      // weighting for individual joints left hand\n\t\t\tsize        // weighting for individual joints right hand\n\n\t\tif (float32Array !== undefined && float32Array.byteLength < bufferSize * 4) {\n\t\t\tthrow Error(`Provided buffer too small it needs to be a float32 and the size needs to be ${bufferSize} (${bufferSize * 4} bytes)`)\n\t\t}\n\t\tconst outData = float32Array || new Float32Array(bufferSize);\n\n\t\toutData[0] = size;\n\t\tconst leftHandAccessor = new Float32Array(outData.buffer, 4, size * 16);\n\t\tconst rightHandAccessor = new Float32Array(outData.buffer, 4 + (size * 16 * 4), size * 16);\n\t\tconst weights = new Float32Array(outData.buffer, 4 + 2 * (size * 16 * 4), size * 2);\n\t\tweights.fill(1);\n\n\t\tframe.fillPoses( tempHands.left.values() , referenceSpace, leftHandAccessor );\n\t\tframe.fillPoses( tempHands.right.values() , referenceSpace, rightHandAccessor );\n\n\t\tnormalize(leftHandAccessor);\n\t\tnormalize(rightHandAccessor);\n\n\t\treturn outData;\n\t}\n}\n\nfunction bufferToFile(outData) {\n\n\tconst a = window.document.createElement('a');\n\n\ta.href = window.URL.createObjectURL(\n\t\tnew Blob(\n\t\t\t[new Uint8Array(outData.buffer)],\n\t\t\t{ type: 'application/octet-stream' }\n\t\t)\n\t);\n\ta.download = 'untitled.handpose';\n\t\n\t// Append anchor to body.\n\tdocument.body.appendChild(a);\n\ta.click();\n\t\n\t// Remove anchor from body\n\tdocument.body.removeChild(a);\n}\n\n\n// what to do once a pose is found\nfunction done(distances, handInfo, callback) {\n\n\tconst detail = {\n\t\thandedness: handInfo.handedness,\n\t\tdistances\n\t};\n\n\tconst handPoseEvent = new CustomEvent('pose', {\n\t\tdetail\n\t});\n\t\n\thandPoses.dispatchEvent(handPoseEvent);\n\tif (callback) {\n\t\tcallback(detail);\n\t}\n}\n\nlet session;\nfunction init(session) {\n\tsession.addEventListener('reset', resetHands);\n\tsession.addEventListener('end', resetHands);\n\tsession.addEventListener('visibilitychange', resetHands);\n\tsession.addEventListener('inputsourceschange', resetHands);\n}\n\n/**\n * \n * @param {Array<XRInputSource>} inputSources The inputs you want to do pose tracking for\n * @param {XRReferenceSpace} referenceSpace The reference space for your scene\n * @param {XRFrame} frame The current active frame\n * @param {function} callback This gets called with an Array of Arrays with the poses and their distances\n */\nexport function update(inputSources, referenceSpace, frame, callback) {\n\n\tif (inputSources && frame) {\n\n\t\tif (frame.session !== session) {\n\t\t\tinit(frame.session);\n\t\t}\n\n\t\tif (__dumphands) {\n\t\t\tconst pose = generatePose(inputSources, referenceSpace, frame);\n\t\t\tif (pose) {\n\t\t\t\t__dumphands = false;\n\t\t\t\tbufferToFile(pose);\n\t\t\t}\n\t\t}\n\n\t\tconst xrViewerPose = frame.getViewerPose(referenceSpace);\n\t\tfor (const source of inputSources) {\t\t\t\n\t\t\tconst hand = source.handedness;\n\t\t\t\n\t\t\tif (!source.hand) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!hands.has(hand)) {\n\t\t\t\tconst handPosePromise = new HandPose();\n\t\t\t\thands.set(hand, handPosePromise);\n\t\t\t\thandPosePromise.then(handPose => {\n\t\t\t\t\tconst session = frame.session;\n\t\t\t\t\tconst handInfo = new HandInfo({session, source, handPose});\n\t\t\t\t\thands.set(hand, handInfo);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst handInfo = hands.get(hand);\n\t\t\t\tif (handInfo instanceof Promise) continue;\n\n\t\t\t\thandInfo.update(xrViewerPose, referenceSpace, frame)\n\t\t\t\t.then(distances => {\n\t\t\t\t\tif (distances.length) {\n\t\t\t\t\t\tdone(distances, handInfo, callback);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch(function (err) {\n\t\t\t\t\tconsole.log(err);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n","\n\t\timport workerPath from \"omt:/home/vincentfretin/workspace/handy-work/src/handpose.js?comlink\";\n\t\timport {wrap} from \"comlink\";\n\n\t\texport default wrap(new Worker(new URL(workerPath, import.meta.url), {type: \"module\"}));\n\t","export default import.meta.ROLLUP_FILE_URL_dc8630b5;"],"names":["HandPose","wrap","Worker","URL","import","meta","url","type","default","loadPose","name","getPose","setPose","pose","window","addEventListener","resetHands","handPoses","EventTarget","HandInfo","ready","constructor","source","handPose","this","size","hand","jointKeys","Array","from","keys","jointMatrixArray","Float32Array","handedness","async","xrViewerPose","referenceSpace","frame","fillPoses","values","returnData","update","transform","matrix","transfer","buffer","usedHandArrayBuffer","distances","hands","Map","clear","__dumphands","dumpHands","generatePose","inputSources","float32Array","tempHands","left","right","bufferSize","undefined","byteLength","Error","outData","leftHandAccessor","rightHandAccessor","fill","normalize","done","handInfo","callback","detail","handPoseEvent","CustomEvent","dispatchEvent","session","init","a","document","createElement","href","createObjectURL","Blob","Uint8Array","download","body","appendChild","click","removeChild","bufferToFile","getViewerPose","has","get","Promise","then","length","catch","err","console","log","handPosePromise","set"],"mappings":"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"}