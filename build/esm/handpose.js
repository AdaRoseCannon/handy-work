import{M as t,Q as e,n as r,t as s,e as a}from"./shared.js";console.log("Worker started");const o=new Map,n=new t,c=new t,f=new e,i=new e;a(Object.freeze({__proto__:null,default:class{#t;constructor(){this.#t=[]}static async loadPose(t,e){const r=new URL(e),s=await fetch(r).then((t=>t.arrayBuffer())),a=new Float32Array(s);o.set(t,a)}static setPose(t,e){o.set(t,e)}static getPose(t){return o.get(t)}update(t,e,a){r(e);const u=[];for(const[t,r]of o){const s=Number("right"===a),o=r[0],l=new Float32Array(r.buffer,4*(1+16*o*s),16*o),h=new Float32Array(r.buffer,4*(1+16*o*2+o*s),o),m=Math.min(o,e.length/16);let w=0,d=1e-4;for(let t=0;t<m;t++){const r=h[t];if(d+=r,0===t)continue;const s=16*t;n.fromArray(l,s),c.fromArray(e,s),f.setFromRotationMatrix(n),i.setFromRotationMatrix(c),w+=f.angleTo(i)*r}w/=d,u.push([t,w])}return s({usedHandArrayBuffer:e,distances:u.sort(((t,e)=>t[1]-e[1]))},[e.buffer])}getMatchedPoses(){return this.#t}}}));
//# sourceMappingURL=handpose.js.map
