import{M as t,Q as e,V as r,n as s,t as a,e as o}from"./shared.js";console.log("Worker started");const n=new Map,c=new t,f=new t,i=new e,u=new e,l=new r,h=new r;o(Object.freeze({__proto__:null,default:class{#t;constructor(){this.#t=[]}static async loadPose(t,e){const r=new URL(e),s=await fetch(r).then((t=>t.arrayBuffer())),a=new Float32Array(s);n.set(t,a)}static setPose(t,e){n.set(t,e)}static getPose(t){return n.get(t)}update(t,e,r){s(e);const o=[];for(const[t,s]of n){const a=Number("right"===r),n=s[0],w=new Float32Array(s.buffer,4*(1+16*n*a),16*n),m=new Float32Array(s.buffer,4*(1+16*n*2+n*a),n),d=Math.min(n,e.length/16);let y=0,p=1e-4;for(let t=0;t<d;t++){const r=m[t];if(p+=r,0===t)continue;const s=16*t;c.fromArray(w,s),f.fromArray(e,s),i.setFromRotationMatrix(c),u.setFromRotationMatrix(f),l.set(0,0,.1).applyQuaternion(i),h.set(0,0,.1).applyQuaternion(u),y+=l.distanceTo(h)*r}y/=p,o.push([t,y])}return a({usedHandArrayBuffer:e,distances:o.sort(((t,e)=>t[1]-e[1]))},[e.buffer])}getMatchedPoses(){return this.#t}}}));
//# sourceMappingURL=handpose.js.map
