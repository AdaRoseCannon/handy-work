import{M as t,Q as e,V as r,n as a,t as s,e as o}from"./shared.js";console.log("Worker started");const n=new Map,c=new t,f=new t,u=new e,i=new e,l=new r,h=new r;o(Object.freeze({__proto__:null,default:class{#t;constructor(){this.#t=[]}static async loadPose(t,e){const r=new URL(e),a=await fetch(r).then((t=>t.arrayBuffer())),s=new Float32Array(a);n.set(t,s)}update(t,e,r){a(e);const o=[];for(const[t,a]of n){const s=Number("right"===r),n=a[0],w=new Float32Array(a.buffer,4*(1+16*n*s),16*n);new Float32Array(a.buffer,4*(1+16*n*2+n*s),n);const m=Math.min(n,e.length/16);let d=0;for(let t=0;t<m;t++){const r=16*t;c.fromArray(w,r),f.fromArray(e,r),u.setFromRotationMatrix(c),i.setFromRotationMatrix(f),l.set(0,0,.1).applyQuaternion(u),h.set(0,0,.1).applyQuaternion(i),d+=l.distanceTo(h)}o.push([t,d])}return s({usedHandArrayBuffer:e,distances:o.sort(((t,e)=>t[1]-e[1]))},[e.buffer])}getPose(t){return n.get(t)}getMatchedPoses(){return this.#t}}}));
//# sourceMappingURL=handpose.js.map
