!function(){"use strict";const t=new THREE.Vector3,e=new THREE.Vector3;AFRAME.registerComponent("linear-constraint",{schema:{axis:{type:"vec3",description:"Axis upon which the element is constrained, does not need to be normalized.",default:{x:0,y:0,z:-1}},max:{description:"How far can it travel along the axis",default:1/0},min:{description:"How far can it travel opposite to the axis",default:-1/0},radius:{description:"Outside this distance it will not work",default:1/0},useFixedValueIfOutOfRange:{description:"Should the object remain at a fixed position if out of the radius.",default:!1},valueIfOutOfRange:{description:"Value the object should be set to if out of the radius",default:0},step:{description:"Steps it should take from the origin.",default:0},target:{description:"Element it should try to follow",type:"selectorAll"},part:{description:"If applied to a 3D model this is the name of the part that should be used instead.",default:""},enabled:{description:"Whether it should currently run or not",default:!0},upEventName:{description:"Name of event to trigger when t is increasing",default:""},upEventThreshold:{description:"Threshold to trigger up event",default:0},downEventName:{description:"Name of event to trigger when t is decreasing",default:""},downEventThreshold:{description:"Threshold to trigger up event",default:0}},init(){this.n=new THREE.Vector3,this.el.addEventListener("object3dset",this.update.bind(this)),this.oldT=null},update(){this.n.copy(this.data.axis).normalize(),this.data.part&&(this.part=this.el.object3D.getObjectByName(this.data.part))},tick(){if(!this.data.enabled||!this.data.target||0===this.data.target.length)return;const i=this.data.part?this.part:this.el.object3D,a=this.data.step;if(!i)return;this.originalOffset||(this.originalOffset=(new THREE.Vector3).copy(i.position));const s=this.n,o=t;let n=1/0;const r=e;for(const t of this.data.target){t.object3D.getWorldPosition(r),i.parent.worldToLocal(r),r.sub(this.originalOffset);const e=r.length();e<n&&(n=e,o.copy(r))}let d=(l=o.dot(s)/s.length(),h=this.data.min,c=this.data.max,Math.min(Math.max(l,h),c));var l,h,c;a&&(d=a*Math.round(d/a));if(o.addScaledVector(s,-d).length()>this.data.radius){if(!this.data.useFixedValueIfOutOfRange)return;d=this.data.valueIfOutOfRange}null!==this.oldT&&(this.data.upEventName&&d>=this.data.upEventThreshold&&this.oldT<this.data.upEventThreshold&&this.el.emit(this.data.upEventName),this.data.downEventName&&d<=this.data.downEventThreshold&&this.oldT>this.data.downEventThreshold&&this.el.emit(this.data.downEventName)),i.position.copy(s).multiplyScalar(d).add(this.originalOffset),this.oldT=d}}),AFRAME.registerComponent("attach-to-model",{schema:{description:"Name of part to follow",default:""},init(){this.el.parentNode.addEventListener("object3dset",this.update.bind(this))},update(){this.data&&(this.part=this.el.parentNode.object3D.getObjectByName(this.data))},tick(){if(this.part){const t=this.el.object3D.position;this.el.object3D.parent.worldToLocal(this.part.getWorldPosition(t))}}});const i=new THREE.Quaternion,a=new THREE.Vector3;AFRAME.registerComponent("grab-magnet-target",{schema:{startEvents:{type:"array",description:"Event to start grabbing"},stopEvents:{type:"array",description:"Event to stop grabbing"},noMagnetEl:{type:"selector",description:"The version of the grip with no magnet providing it helps physics things."}},init(){this.grabStart=this.grabStart.bind(this),this.grabEnd=this.grabEnd.bind(this),this.isGrabbing=!1,this.oldParent=null,this.grabbedEl=null,this.targetEl=null,this.oldQuaternion=new THREE.Quaternion,this.oldPosition=new THREE.Quaternion},update(t){if(t.startEvents)for(const e of t.startEvents)this.el.removeEventListener(e,this.grabStart);if(t.stopEvents)for(const e of t.stopEvents)this.el.removeEventListener(e,this.grabEnd);for(const t of this.data.startEvents)this.el.addEventListener(t,this.grabStart);for(const t of this.data.stopEvents)this.el.addEventListener(t,this.grabEnd)},grabStart(t){const e=this.el.dataset.magnetTarget;if(!1===this.isGrabbing&&e){const s=this.el.dataset.magnet.split(" "),o=document.getElementById(e),n=o.dataset.pickUp,r="parent"===n?o.parentNode:o;if(this.isGrabbing=!0,this.grabbedEl=r,this.targetEl=o,this.removedClasses=[],void 0!==n){for(const t of s)r.classList.contains(t)&&(r.classList.remove(t),this.removedClasses.push(t));const e=r.dataset.oldGrabber;e&&document.getElementById(e).components["grab-magnet-target"].grabEnd(t),r.dataset.oldGrabber=this.el.id,this.oldParent=r.parentNode,this.el.add(r),this.oldQuaternion.copy(r.object3D.quaternion),r.object3D.quaternion.identity(),this.oldPosition.copy(r.object3D.position),r.object3D.position.set(0,0,0),"parent"===n&&(i.copy(o.object3D.quaternion).invert(),a.copy(o.object3D.position).applyQuaternion(i),r.object3D.applyQuaternion(i),r.object3D.position.sub(a)),r.emit("pickup",Object.assign({by:this.el,byNoMagnet:this.data.noMagnetEl},t&&t.detail))}r.emit("grabbed",Object.assign({by:this.el,byNoMagnet:this.data.noMagnetEl},t&&t.detail))}},grabEnd(t){if(this.isGrabbing){const e=this.grabbedEl;if(this.oldParent){for(const t of this.removedClasses.splice(0))e.classList.add(t);delete e.dataset.oldGrabber,void 0!==e.dataset.resetTransform?(e.object3D.quaternion.copy(this.oldQuaternion),e.object3D.position.copy(this.oldPosition)):(this.oldParent.object3D.worldToLocal(e.object3D.getWorldPosition(e.object3D.position)),this.oldParent.object3D.getWorldQuaternion(i).invert(),e.object3D.getWorldQuaternion(e.object3D.quaternion).premultiply(i)),this.oldParent.add(e),this.oldParent=null,e.emit("putdown",Object.assign({by:this.el,byNoMagnet:this.data.noMagnetEl},t&&t.detail))}this.isGrabbing=!1,this.grabbedEl=null,this.targetEl=null,e.emit("released",Object.assign({by:this.el,byNoMagnet:this.data.noMagnetEl},t&&t.detail))}},tick(){this.isGrabbing&&void 0===this.targetEl.dataset.pickUp&&this.el.dataset.magnetTarget!==this.targetEl.id&&this.grabEnd()}})}();
//# sourceMappingURL=magnet-helpers.min.js.map
