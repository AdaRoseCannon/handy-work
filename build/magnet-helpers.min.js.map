{"version":3,"file":"magnet-helpers.min.js","sources":["../src/magnet-helpers.js"],"sourcesContent":["/* eslint-disable no-unused-labels */\n/* jshint esversion: 9 */\n/* global THREE, AFRAME */\n\ndocumentation:\nconsole.log(`### linear-constraint\n\nlinear-constraint is designed to place the element it's attached to \nplace elements as close as possible to the target element whilst being restrained along a line\ndefined by the \\`axis\\`, between the \\`min\\` and \\`max\\` on either side of the original position\nof the object when this component is first run.\n\nThis is useful for creating magnetic lines. Put linear-constraint on a magnetic element and set it's target\nto the **non-magnet** version of the hand element with the data-magnet property. i.e. the same part but with \\`data-no-magnet\\`\n`);\n\nconst clamp = (num, min, max) => Math.min(Math.max(num, min), max);\nAFRAME.registerComponent('linear-constraint', {\n\tschema: {\n\t\taxis: {\n\t\t\ttype: 'vec3',\n\t\t\tdescription: `Axis upon which the element is constrained, does not need to be normalized.`,\n\t\t\tdefault: { x: 0, y: 0, z: -1 }\n\t\t},\n\t\tmax: {\n\t\t\tdescription: `How far can it travel along the axis`,\n\t\t\tdefault: Infinity\n\t\t},\n\t\tmin: {\n\t\t\tdescription: `How far can it travel opposite to the axis`,\n\t\t\tdefault: -Infinity\n\t\t},\n\t\tstep: {\n\t\t\tdescription: \"Steps it should take from the origin.\",\n\t\t\tdefault: 0\n\t\t},\n\t\ttarget: {\n\t\t\tdescription: `Element it should try to follow`,\n\t\t\ttype: 'selector'\n\t\t},\n\t\tpart: {\n\t\t\tdescription: `If applied to a 3D model this is the name of the part that should be used instead.`,\n\t\t\tdefault: ''\n\t\t},\n\t\tenabled: {\n\t\t\tdescription: `Whether it should currently run or not`,\n\t\t\tdefault: true\n\t\t}\n\t},\n\tinit() {\n\t\tthis.tempVec3 = new THREE.Vector3();\n\t\tthis.n = new THREE.Vector3();\n\t\tthis.el.addEventListener('object3dset', this.update.bind(this));\n\t},\n\tupdate() {\n\t\t// Ensure the axis is normalized\n\t\tthis.n.copy(this.data.axis).normalize();\n\t\tif (this.data.part) this.part = this.el.object3D.getObjectByName(this.data.part);\n\t},\n\ttick() {\n\t\tif (!this.data.enabled || !this.data.target) return;\n\t\tconst object3D = this.data.part ? this.part : this.el.object3D;\n\t\tconst step = this.data.step;\n\t\tif (!object3D) return;\n\t\tif (!this.originalOffset) this.originalOffset = new THREE.Vector3().copy(object3D.position);\n\t\tconst n = this.n;\n\t\tconst p0 = this.tempVec3;\n\t\tthis.data.target.object3D.getWorldPosition(p0);\n\t\tobject3D.parent.worldToLocal(p0);\n\t\tp0.sub(this.originalOffset);\n\t\t// We have a plane with normal n that contains p0\n\t\t// We want to place the object where a vector n from the origin intersects the plane\n\t\t// n.x x + n.y y + n.z z = p0.n\n\t\t// Sub in vector equation p=tn\n\t\t// t * n.x * n.x + t * n.y * n.y + t * n.z * n.z = p0.n\n\t\t// equivalent to  t * n.length() = p0.n\n\t\tlet t = clamp(p0.dot(n) / n.length(), this.data.min, this.data.max);\n\t\tif (step) t = step*Math.round(t/step);\n\t\tobject3D.position.copy(n).multiplyScalar(t).add(this.originalOffset);\n\t}\n});\n\ndocumentation:\nconsole.log(`### attach-to-model\n\nEach frame attach-to-model will move an object to the same position as part of the 3D model of it's parent element.\n\nThis is useful for attaching magnetic elements to moving elements of a 3D model so it can be grabbed in different ways.\n`);\nAFRAME.registerComponent(\"attach-to-model\", {\n\tschema: {\n\t\tdescription: `Name of part to follow`,\n\t\tdefault: ''\n\t},\n\tinit() {\n\t\tthis.el.parentNode.addEventListener('object3dset', this.update.bind(this));\n\t},\n\tupdate() {\n\t\tif (this.data) this.part = this.el.parentNode.object3D.getObjectByName(this.data);\n\t},\n\ttick() {\n\t\tif (this.part) {\n\t\t\tconst p = this.el.object3D.position;\n\t\t\tthis.el.object3D.parent.worldToLocal(this.part.getWorldPosition(p));\n\t\t}\n\t}\n});\n\n\ndocumentation:\nconsole.log(`### grab-magnet-target\n\nThis should be added to the hand elements with the \\`data-magnet\\`.\n\nWhen one of the \\`startEvents\\` events is fired it will start a grab action where it will\nconsider itself grabbing whatever magnetic item it is currently being attracted to and fires the \"grabbed\" event\non the object.\n\nIf the object has \\`data-pick-up\\` set then the object will be reparented to the hand element that fired\nthe grab event. The \"pickup\" event will be fired on the object.\n\nIf the object has \\`data-pick-up=\"parent\"\\` set then the object's parent will be reparented to the hand element that fired\nthe grab event. The \"pickup\" event will be fired on the object's parent.\n\nWhen either the release event is fired or the object stops being magnet target then it will consider itself released.\nit will reparent objects back to where they were originally and fire the \"putdown\" event on what was held if it had been picked up.\nIf the held object has \\`data-reset-transform\\` set then it will also restore it's oriingal position. Otherwise the world position and rotation of the object will remain the same.\n\nFinally the \"released\" event is fired on whatever was being held.\n`);\n\nconst tempQuaternion = new THREE.Quaternion();\nconst tempVector3 = new THREE.Vector3();\nAFRAME.registerComponent(\"grab-magnet-target\", {\n\tschema: {\n\t\tstartEvents: {\n\t\t\ttype: 'array',\n\t\t\tdescription: 'Event to start grabbing'\n\t\t},\n\t\tstopEvents: {\n\t\t\ttype: 'array',\n\t\t\tdescription: 'Event to stop grabbing'\n\t\t}\n\t},\n\tinit() {\n\t\tthis.grabStart = this.grabStart.bind(this);\n\t\tthis.grabEnd = this.grabEnd.bind(this);\n\t\tthis.isGrabbing = false;\n\t\tthis.oldParent = null;\n\t\tthis.grabbedEl = null;\n\t\tthis.targetEl = null;\n\t\tthis.oldQuaternion = new THREE.Quaternion();\n\t\tthis.oldPosition = new THREE.Quaternion();\n\t},\n\tupdate(oldData) {\n\t\tif (oldData.startEvents) {\n\t\t\tfor (const eventName of oldData.startEvents) {\n\t\t\t\tthis.el.removeEventListener(eventName, this.grabStart);\n\t\t\t}\n\t\t}\n\t\tif (oldData.stopEvents) {\n\t\t\tfor (const eventName of oldData.stopEvents) {\n\t\t\t\tthis.el.removeEventListener(eventName, this.grabEnd);\n\t\t\t}\n\t\t}\n\t\tfor (const eventName of this.data.startEvents) {\n\t\t\tthis.el.addEventListener(eventName, this.grabStart);\n\t\t}\n\t\tfor (const eventName of this.data.stopEvents) {\n\t\t\tthis.el.addEventListener(eventName, this.grabEnd);\n\t\t}\n\t},\n\tgrabStart(e) {\n\t\tconst targetId = this.el.dataset.magnetTarget;\n\t\tif (this.isGrabbing === false && targetId) {\n\t\t\tconst magnetClasses = this.el.dataset.magnet.split(' ');\n\t\t\tconst target = document.getElementById(targetId);\n\t\t\tconst pickUp = target.dataset.pickUp;\n\t\t\tconst el = pickUp === 'parent' ? target.parentNode : target;\n\t\t\tthis.isGrabbing = true;\n\t\t\tthis.grabbedEl = el;\n\t\t\tthis.targetEl = target;\n\t\t\tthis.removedClasses = [];\n\t\t\tif (pickUp !== undefined) {\n\t\t\t\tfor (const classname of magnetClasses) {\n\t\t\t\t\tif (el.classList.contains(classname)) {\n\t\t\t\t\t\tel.classList.remove(classname);\n\t\t\t\t\t\tthis.removedClasses.push(classname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst oldGrabber = el.dataset.oldGrabber;\n\t\t\t\tif (oldGrabber) document.getElementById(oldGrabber).components[\"grab-magnet-target\"].grabEnd(e);\n\t\t\t\tel.dataset.oldGrabber = this.el.id;\n\n\t\t\t\tthis.oldParent = el.parentNode;\n\t\t\t\tthis.el.add(el);\n\t\t\t\tthis.oldQuaternion.copy(el.object3D.quaternion);\n\t\t\t\tel.object3D.quaternion.identity();\n\t\t\t\tthis.oldPosition.copy(el.object3D.position);\n\t\t\t\tel.object3D.position.set(0, 0, 0);\n\t\t\t\tif (pickUp === 'parent') {\n\t\t\t\t\ttempQuaternion.copy(target.object3D.quaternion).invert();\n\t\t\t\t\ttempVector3.copy(target.object3D.position).applyQuaternion(tempQuaternion);\n\t\t\t\t\tel.object3D.applyQuaternion(tempQuaternion);\n\t\t\t\t\tel.object3D.position.sub(tempVector3);\n\t\t\t\t}\n\t\t\t\tel.emit('pickup', Object.assign({ by: this.el }, e && e.detail));\n\t\t\t}\n\t\t\tel.emit('grabbed', Object.assign({ by: this.el }, e && e.detail));\n\t\t}\n\t},\n\tgrabEnd(e) {\n\t\tif (this.isGrabbing) {\n\t\t\tconst el = this.grabbedEl;\n\t\t\tif (this.oldParent) {\n\t\t\t\tfor (const classname of this.removedClasses.splice(0)) {\n\t\t\t\t\tel.classList.add(classname);\n\t\t\t\t}\n\t\t\t\tdelete el.dataset.oldGrabber;\n\t\t\t\tif (el.dataset.resetTransform !== undefined) {\n\t\t\t\t\tel.object3D.quaternion.copy(this.oldQuaternion);\n\t\t\t\t\tel.object3D.position.copy(this.oldPosition);\n\t\t\t\t} else {\n\t\t\t\t\t// Keep in place in the new parent\n\t\t\t\t\tthis.oldParent.object3D.worldToLocal(el.object3D.getWorldPosition(el.object3D.position));\n\n\t\t\t\t\tthis.oldParent.object3D.getWorldQuaternion(tempQuaternion).invert();\n\t\t\t\t\tel.object3D.getWorldQuaternion(el.object3D.quaternion).premultiply(tempQuaternion);\n\t\t\t\t}\n\t\t\t\tthis.oldParent.add(el);\n\t\t\t\tthis.oldParent = null;\n\t\t\t\tel.emit('putdown', Object.assign({ by: this.el }, e && e.detail));\n\t\t\t}\n\t\t\tthis.isGrabbing = false;\n\t\t\tthis.grabbedEl = null;\n\t\t\tthis.targetEl = null;\n\t\t\tel.emit('released', Object.assign({ by: this.el }, e && e.detail));\n\t\t}\n\t},\n\ttick() {\n\t\tif (this.isGrabbing) {\n\t\t\tif (this.targetEl.dataset.pickUp === undefined && this.el.dataset.magnetTarget !== this.targetEl.id) {\n\t\t\t\tthis.grabEnd();\n\t\t\t}\n\t\t}\n\t}\n});\n"],"names":["AFRAME","registerComponent","schema","axis","type","description","default","x","y","z","max","Infinity","min","step","target","part","enabled","init","this","tempVec3","THREE","Vector3","n","el","addEventListener","update","bind","copy","data","normalize","object3D","getObjectByName","tick","originalOffset","position","p0","getWorldPosition","parent","worldToLocal","sub","t","num","dot","length","Math","round","multiplyScalar","add","parentNode","p","tempQuaternion","Quaternion","tempVector3","startEvents","stopEvents","grabStart","grabEnd","isGrabbing","oldParent","grabbedEl","targetEl","oldQuaternion","oldPosition","oldData","eventName","removeEventListener","e","targetId","dataset","magnetTarget","magnetClasses","magnet","split","document","getElementById","pickUp","removedClasses","undefined","classname","classList","contains","remove","push","oldGrabber","components","id","quaternion","identity","set","invert","applyQuaternion","emit","Object","assign","by","detail","splice","resetTransform","getWorldQuaternion","premultiply"],"mappings":"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"}