!function(){"use strict";const e={Handedness:Object.freeze({NONE:"none",LEFT:"left",RIGHT:"right"}),ComponentState:Object.freeze({DEFAULT:"default",TOUCHED:"touched",PRESSED:"pressed"}),ComponentProperty:Object.freeze({BUTTON:"button",X_AXIS:"xAxis",Y_AXIS:"yAxis",STATE:"state"}),ComponentType:Object.freeze({TRIGGER:"trigger",SQUEEZE:"squeeze",TOUCHPAD:"touchpad",THUMBSTICK:"thumbstick",BUTTON:"button"}),ButtonTouchThreshold:.05,AxisTouchThreshold:.1,VisualResponseProperty:Object.freeze({TRANSFORM:"transform",VISIBILITY:"visibility"})};async function t(e){const t=await fetch(e);if(t.ok)return t.json();throw new Error(t.statusText)}async function o(e,o,s=null,i=!0){if(!e)throw new Error("No xrInputSource supplied");if(!o)throw new Error("No basePath supplied");const n=await async function(e){if(!e)throw new Error("No basePath supplied");return await t(`${e}/profilesList.json`)}(o);let a;if(e.profiles.some((e=>{const t=n[e];return t&&(a={profileId:e,profilePath:`${o}/${t.path}`,deprecated:!!t.deprecated}),!!a})),!a){if(!s)throw new Error("No matching profile name found");const e=n[s];if(!e)throw new Error(`No matching profile name found and default profile "${s}" missing.`);a={profileId:s,profilePath:`${o}/${e.path}`,deprecated:!!e.deprecated}}const r=await t(a.profilePath);let l;if(i){let t;if(t="any"===e.handedness?r.layouts[Object.keys(r.layouts)[0]]:r.layouts[e.handedness],!t)throw new Error(`No matching handedness, ${e.handedness}, in profile ${a.profileId}`);t.assetPath&&(l=a.profilePath.replace("profile.json",t.assetPath))}return{profile:r,assetPath:l}}const s={xAxis:0,yAxis:0,button:0,state:e.ComponentState.DEFAULT};class i{constructor(t){this.componentProperty=t.componentProperty,this.states=t.states,this.valueNodeName=t.valueNodeName,this.valueNodeProperty=t.valueNodeProperty,this.valueNodeProperty===e.VisualResponseProperty.TRANSFORM&&(this.minNodeName=t.minNodeName,this.maxNodeName=t.maxNodeName),this.value=0,this.updateFromComponent(s)}updateFromComponent({xAxis:t,yAxis:o,button:s,state:i}){const{normalizedXAxis:n,normalizedYAxis:a}=function(e=0,t=0){let o=e,s=t;if(Math.sqrt(e*e+t*t)>1){const i=Math.atan2(t,e);o=Math.cos(i),s=Math.sin(i)}return{normalizedXAxis:.5*o+.5,normalizedYAxis:.5*s+.5}}(t,o);switch(this.componentProperty){case e.ComponentProperty.X_AXIS:this.value=this.states.includes(i)?n:.5;break;case e.ComponentProperty.Y_AXIS:this.value=this.states.includes(i)?a:.5;break;case e.ComponentProperty.BUTTON:this.value=this.states.includes(i)?s:0;break;case e.ComponentProperty.STATE:this.valueNodeProperty===e.VisualResponseProperty.VISIBILITY?this.value=this.states.includes(i):this.value=this.states.includes(i)?1:0;break;default:throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`)}}}class n{constructor(t,o){if(!(t&&o&&o.visualResponses&&o.gamepadIndices&&0!==Object.keys(o.gamepadIndices).length))throw new Error("Invalid arguments supplied");this.id=t,this.type=o.type,this.rootNodeName=o.rootNodeName,this.touchPointNodeName=o.touchPointNodeName,this.visualResponses={},Object.keys(o.visualResponses).forEach((e=>{const t=new i(o.visualResponses[e]);this.visualResponses[e]=t})),this.gamepadIndices=Object.assign({},o.gamepadIndices),this.values={state:e.ComponentState.DEFAULT,button:void 0!==this.gamepadIndices.button?0:void 0,xAxis:void 0!==this.gamepadIndices.xAxis?0:void 0,yAxis:void 0!==this.gamepadIndices.yAxis?0:void 0}}get data(){return{id:this.id,...this.values}}updateFromGamepad(t){if(this.values.state=e.ComponentState.DEFAULT,void 0!==this.gamepadIndices.button&&t.buttons.length>this.gamepadIndices.button){const o=t.buttons[this.gamepadIndices.button];this.values.button=o.value,this.values.button=this.values.button<0?0:this.values.button,this.values.button=this.values.button>1?1:this.values.button,o.pressed||1===this.values.button?this.values.state=e.ComponentState.PRESSED:(o.touched||this.values.button>e.ButtonTouchThreshold)&&(this.values.state=e.ComponentState.TOUCHED)}void 0!==this.gamepadIndices.xAxis&&t.axes.length>this.gamepadIndices.xAxis&&(this.values.xAxis=t.axes[this.gamepadIndices.xAxis],this.values.xAxis=this.values.xAxis<-1?-1:this.values.xAxis,this.values.xAxis=this.values.xAxis>1?1:this.values.xAxis,this.values.state===e.ComponentState.DEFAULT&&Math.abs(this.values.xAxis)>e.AxisTouchThreshold&&(this.values.state=e.ComponentState.TOUCHED)),void 0!==this.gamepadIndices.yAxis&&t.axes.length>this.gamepadIndices.yAxis&&(this.values.yAxis=t.axes[this.gamepadIndices.yAxis],this.values.yAxis=this.values.yAxis<-1?-1:this.values.yAxis,this.values.yAxis=this.values.yAxis>1?1:this.values.yAxis,this.values.state===e.ComponentState.DEFAULT&&Math.abs(this.values.yAxis)>e.AxisTouchThreshold&&(this.values.state=e.ComponentState.TOUCHED)),Object.values(this.visualResponses).forEach((e=>{e.updateFromComponent(this.values)}))}}class a{constructor(e,t,o){if(!e)throw new Error("No xrInputSource supplied");if(!t)throw new Error("No profile supplied");this.xrInputSource=e,this.assetUrl=o,this.id=t.profileId,this.layoutDescription=t.layouts[e.handedness],this.components={},Object.keys(this.layoutDescription.components).forEach((e=>{const t=this.layoutDescription.components[e];this.components[e]=new n(e,t)})),this.updateFromGamepad()}get gripSpace(){return this.xrInputSource.gripSpace}get targetRaySpace(){return this.xrInputSource.targetRaySpace}get data(){const e=[];return Object.values(this.components).forEach((t=>{e.push(t.data)})),e}updateFromGamepad(){Object.values(this.components).forEach((e=>{e.updateFromGamepad(this.xrInputSource.gamepad)}))}}const{Mesh:r,MeshBasicMaterial:l,Object3D:h,SphereGeometry:d}=THREE;class c extends h{constructor(){super(),this.motionController=null,this.envMap=null}setEnvironmentMap(e){return this.envMap==e||(this.envMap=e,this.traverse((e=>{e.isMesh&&(e.material.envMap=this.envMap,e.material.needsUpdate=!0)}))),this}updateMatrixWorld(t){super.updateMatrixWorld(t),this.motionController&&(this.motionController.updateFromGamepad(),Object.values(this.motionController.components).forEach((t=>{Object.values(t.visualResponses).forEach((t=>{const{valueNode:o,minNode:s,maxNode:i,value:n,valueNodeProperty:a}=t;o&&(a===e.VisualResponseProperty.VISIBILITY?o.visible=n:a===e.VisualResponseProperty.TRANSFORM&&(o.quaternion.slerpQuaternions(s.quaternion,i.quaternion,n),o.position.lerpVectors(s.position,i.position,n)))}))})))}}function p(t,o){!function(t,o){Object.values(t.components).forEach((t=>{const{type:s,touchPointNodeName:i,visualResponses:n}=t;if(s===e.ComponentType.TOUCHPAD)if(t.touchPointNode=o.getObjectByName(i),t.touchPointNode){const e=new d(.001),o=new l({color:255}),s=new r(e,o);t.touchPointNode.add(s)}else console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);Object.values(n).forEach((t=>{const{valueNodeName:s,minNodeName:i,maxNodeName:n,valueNodeProperty:a}=t;if(a===e.VisualResponseProperty.TRANSFORM){if(t.minNode=o.getObjectByName(i),t.maxNode=o.getObjectByName(n),!t.minNode)return void console.warn(`Could not find ${i} in the model`);if(!t.maxNode)return void console.warn(`Could not find ${n} in the model`)}t.valueNode=o.getObjectByName(s),t.valueNode||console.warn(`Could not find ${s} in the model`)}))}))}(t.motionController,o),t.envMap&&o.traverse((e=>{e.isMesh&&(e.material.envMap=t.envMap,e.material.needsUpdate=!0)})),t.add(o)}class u{constructor(e){this.gltfLoader=e,this.path="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles",this._assetCache={}}createControllerModel(e){const t=new c;let s=null;return e.addEventListener("connected",(e=>{const i=e.data;"tracked-pointer"===i.targetRayMode&&i.gamepad&&o(i,this.path,"generic-trigger").then((({profile:e,assetPath:o})=>{t.motionController=new a(i,e,o);const n=this._assetCache[t.motionController.assetUrl];if(n)s=n.scene.clone(),p(t,s);else{if(!this.gltfLoader)throw new Error("GLTFLoader not set.");this.gltfLoader.setPath(""),this.gltfLoader.load(t.motionController.assetUrl,(e=>{this._assetCache[t.motionController.assetUrl]=e,s=e.scene.clone(),p(t,s)}),null,(()=>{throw new Error(`Asset ${t.motionController.assetUrl} missing or malformed.`)}))}})).catch((e=>{console.warn(e)}))})),e.addEventListener("disconnected",(()=>{t.motionController=null,t.remove(s),s=null})),t}}const m="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/",f="https://cdn.jsdelivr.net/npm/handy-work@1.5.0",g=f+"/poses/",b=(e,t,o)=>((e,t=0,o=1)=>Math.min(o,Math.max(t,e)))((o-e)/(t-e)),v=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"];AFRAME.registerComponent("handy-controls",{schema:{left:{description:"URL for left controller",type:"model",default:m+"left.glb"},right:{description:"URL for right controller",type:"model",default:m+"right.glb"},materialOverride:{description:"Which hand to use the `material` component for",oneOf:["both","left","right","none"],default:"both"},fuseVShort:{description:"Time for a pose to trigger a pose event (ms)",default:48},fuseShort:{description:"Time for a pose to trigger a pose_fuseShort event (ms)",default:480},fuseLong:{description:"Time for a pose to trigger a pose_fuseLong event (ms)",default:1440}},init(){this.handyWorkCallback=this.handyWorkCallback.bind(this);const e=this.el.sceneEl.getAttribute("webxr"),t=e.optionalFeatures;t.includes("hand-tracking")||(t.push("hand-tracking"),this.el.sceneEl.setAttribute("webxr",e)),this.loader=new THREE.GLTFLoader;const o=this,s=this.el.sceneEl.systems["gltf-model"].getDRACOLoader(),i=this.el.sceneEl.systems["gltf-model"].getMeshoptDecoder();this.controllerModelFactory=new u(this.loader),this.model=null,s&&this.loader.setDRACOLoader(s),this.ready=i?i.then((function(e){o.loader.setMeshoptDecoder(e)})):Promise.resolve(),import("https://cdn.jsdelivr.net/npm/handy-work@1.5.0/build/esm/handy-work.standalone.js").then(function({update:e,loadPose:t,dumpHands:o,setPose:s,getPose:i}){this.handyWorkUpdate=e,this.dumpHands=o,this.loadPose=t,this.setPose=s,this.getPose=i,t("relax",g+"relax.handpose"),t("fist",g+"fist.handpose"),t("flat",g+"flat.handpose"),t("point",g+"point.handpose"),t("horns",g+"horns.handpose"),t("shaka",g+"shaka.handpose"),t("vulcan",g+"vulcan.handpose")}.bind(this));for(const e of["left","right"]){const t=Array.from(this.el.querySelectorAll(`[data-${e}]`));for(const e of t)e.object3D.visible=!1}this.gripOffset={right:new THREE.Vector3(-.005,-.03,0),left:new THREE.Vector3(.005,-.03,0)},this.gripQuaternions={right:[(new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(0,0,-1),new THREE.Vector3(-1,0,0).normalize()),(new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(0,1,0),new THREE.Vector3(-1,0,0))],left:[(new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(0,0,1),new THREE.Vector3(1,0,0).normalize()),(new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(1,1,0),new THREE.Vector3(-1,0,-1))]},this.tempVector3=new THREE.Vector3,this.tempVector3_A=new THREE.Vector3,this.tempVector3_B=new THREE.Vector3,this.tempQuaternion_A=new THREE.Quaternion,this.tempQuaternion_B=new THREE.Quaternion},async gltfToJoints(e,t){const o=this.el;await this.ready;const s=(await new Promise(function(t,o){this.loader.load(e,t,void 0,o)}.bind(this))).scene.children[0],i=s.getObjectByProperty("type","SkinnedMesh");this.el.components.material&&("both"!==this.data.materialOverride&&this.data.materialOverride!==t||(i.material=this.el.components.material.material)),i.visible=!1,i.frustumCulled=!1,i.castShadow=!0,i.receiveShadow=!0,i.skeleton.pose();const n=[];for(const t of v){const o=s.getObjectByName(t);void 0!==o?(o.jointName=t,n.push(o),o.applyMatrix4(this.el.object3D.matrixWorld),o.updateMatrixWorld()):(console.warn(`Couldn't find ${t} in ${e} hand mesh`),n.push(void 0))}return o.setObject3D("hand-mesh-"+t,i),o.emit("model-loaded",{format:"gltf",model:i}),n},async update(e){const t=this.el,o=this.data.left,s=this.data.right;if(e.left!==this.data.left||e.right!==this.data.right){this.remove();try{this.bonesRight=await this.gltfToJoints(s,"right"),this.bonesLeft=await this.gltfToJoints(o,"left")}catch(e){const o=e&&e.message?e.message:"Failed to load glTF model";console.warn(o),t.emit("hand-model-error",{message:o})}}},getControllerModel(e,t){const o=this.el.getObject3D("controller-model-"+t.handedness);if(o)return o;{const o=this.el.sceneEl.renderer.xr.getControllerGrip(e),s=this.controllerModelFactory.createControllerModel(o);return o.add(s),this.el.setObject3D("controller-model-"+t.handedness,o),o}},tick(){const e=this.el.sceneEl.xrSession;if(!e)return;const t=this.el.sceneEl.renderer.xr.getReferenceSpace(),o=[],s=this.el.sceneEl.frame;let i=-1;e:for(const n of e.inputSources){i++;const e=this.el.querySelector(`[data-magnet][data-${n.handedness}]`);let a=null,r=1,l=[];const h=this.el.getObject3D("hand-mesh-"+n.handedness);if(!h)return;const d=Array.from(this.el.querySelectorAll(`[data-${n.handedness}]`)),c=new Map;for(const e of d){const t=e.dataset[n.handedness],o=c.get(t)||[];o.push(e),c.set(t,o)}if(n.hand){o.push(n);const e=this.el.getObject3D("controller-model-"+n.handedness);if(e&&(e.visible=!1),l="right"===n.handedness&&this.bonesRight||"left"===n.handedness&&this.bonesLeft,!l.length)continue;for(const e of l){const o=n.hand.get(e.jointName);if(o){const i=s.getJointPose(o,t);if(!i)continue e;if(h.visible=!0,c.has(e.jointName))for(const t of c.get(e.jointName))t.object3D.position.copy(i.transform.position),t.object3D.quaternion.copy(i.transform.orientation),t.object3D.visible=!1!==t.getDOMAttribute("visible");if("middle-finger-metacarpal"===e.jointName&&c.has("grip"))for(const e of c.get("grip"))e.object3D.quaternion.copy(i.transform.orientation),this.gripQuaternions[n.handedness].forEach((t=>e.object3D.quaternion.multiply(t))),e.object3D.position.copy(this.gripOffset[n.handedness]),e.object3D.position.applyQuaternion(e.object3D.quaternion),e.object3D.position.add(i.transform.position),e.object3D.visible=!1!==e.getDOMAttribute("visible");e.position.copy(i.transform.position),e.quaternion.copy(i.transform.orientation)}}}else{for(const e of d)e.object3D.visible=!1;h.visible=!1;if(this.getControllerModel(i,n).visible=!0,c.has("grip")&&n.gripSpace){const e=s.getPose(n.gripSpace,t);if(e)for(const t of c.get("grip"))t.object3D.position.copy(e.transform.position),t.object3D.quaternion.copy(e.transform.orientation),t.object3D.visible=!1!==t.getDOMAttribute("visible")}}if(c.has("ray")&&n.targetRaySpace){const e=s.getPose(n.targetRaySpace,t);if(e)for(const t of c.get("ray"))t.object3D.position.copy(e.transform.position),t.object3D.quaternion.copy(e.transform.orientation),t.object3D.visible=!1!==t.getDOMAttribute("visible")}if(e){e.object3D.updateWorldMatrix(!0,!1);const t=Array.from(document.querySelectorAll(e.dataset.magnet));for(const o of t){const[t,s]=(o.dataset.magnetRange||"0.2,0.1").split(",").map((e=>Number(e)));o.object3D.getWorldPosition(this.tempVector3),e.object3D.worldToLocal(this.tempVector3);const i=this.tempVector3.length();if(i<t){a=o,r=s?b(t,s,i):1;break}}}if(a){a.object3D.getWorldPosition(this.tempVector3_A),e.object3D.getWorldPosition(this.tempVector3_B),this.tempVector3_A.lerp(this.tempVector3_B,1-r).sub(this.tempVector3_B),a.object3D.getWorldQuaternion(this.tempQuaternion_A),e.object3D.getWorldQuaternion(this.tempQuaternion_B),this.tempQuaternion_A.slerp(this.tempQuaternion_B,1-r).multiply(this.tempQuaternion_B.invert());for(const t of l)t.position.sub(e.object3D.position),t.position.applyQuaternion(this.tempQuaternion_A),t.position.add(e.object3D.position),t.applyQuaternion(this.tempQuaternion_A),t.position.add(this.tempVector3_A),t.applyMatrix4(this.el.object3D.matrixWorld),t.updateMatrixWorld();for(const t of d.filter((e=>void 0===e.dataset.noMagnet)))t.object3D.position.sub(e.object3D.position),t.object3D.position.applyQuaternion(this.tempQuaternion_A),t.object3D.position.add(e.object3D.position),t.object3D.applyQuaternion(this.tempQuaternion_A),t.object3D.position.add(this.tempVector3_A)}else for(const e of l)e.applyMatrix4(this.el.object3D.matrixWorld),e.updateMatrixWorld()}o.length&&this.handyWorkUpdate&&this.handyWorkUpdate(o,t,s,this.handyWorkCallback)},handyWorkCallback:function({distances:e,handedness:t}){this.emit(e[0][0],t,{pose:e[0][0],poses:e,handedness:t})},emit(e,t,o){if(e===this[t+"_currentPose"])return;const s=Array.from(this.el.querySelectorAll(`[data-${t}]`));clearTimeout(this[t+"_vshortTimeout"]),clearTimeout(this[t+"_shortTimeout"]),clearTimeout(this[t+"_longTimeout"]),this[t+"_currentPose"]=e,this[t+"_vshortTimeout"]=setTimeout((()=>{this.el.emit("pose_"+e,o),this.el.emit("pose",o);for(const t of s)t.emit("pose_"+e,o,!1),t.emit("pose",o,!1)}),this.data.fuseVShort),this[t+"_shortTimeout"]=setTimeout((()=>{this.el.emit("pose_"+e+"_fuseShort",o);for(const t of s)t.emit("pose_"+e+"_fuseShort",o,!1)}),this.data.fuseShort),this[t+"_longTimeout"]=setTimeout((()=>{this.el.emit("pose_"+e+"_fuseLong",o);for(const t of s)t.emit("pose_"+e+"_fuseLong",o,!1)}),this.data.fuseLong)},remove(){this.bonesLeft&&(this.bonesLeft=null,this.el.removeObject3D("hand-mesh-left")),this.bonesRight&&(this.bonesRight=null,this.el.removeObject3D("hand-mesh-right"))}})}();
//# sourceMappingURL=handy-controls.min.js.map
