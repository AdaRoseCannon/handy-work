!function(){"use strict";const e={Handedness:Object.freeze({NONE:"none",LEFT:"left",RIGHT:"right"}),ComponentState:Object.freeze({DEFAULT:"default",TOUCHED:"touched",PRESSED:"pressed"}),ComponentProperty:Object.freeze({BUTTON:"button",X_AXIS:"xAxis",Y_AXIS:"yAxis",STATE:"state"}),ComponentType:Object.freeze({TRIGGER:"trigger",SQUEEZE:"squeeze",TOUCHPAD:"touchpad",THUMBSTICK:"thumbstick",BUTTON:"button"}),ButtonTouchThreshold:.05,AxisTouchThreshold:.1,VisualResponseProperty:Object.freeze({TRANSFORM:"transform",VISIBILITY:"visibility"})};async function t(e){const t=await fetch(e);if(t.ok)return t.json();throw new Error(t.statusText)}async function o(e,o,s=null,n=!0){if(!e)throw new Error("No xrInputSource supplied");if(!o)throw new Error("No basePath supplied");const i=await async function(e){if(!e)throw new Error("No basePath supplied");return await t(`${e}/profilesList.json`)}(o);let a;if(e.profiles.some((e=>{const t=i[e];return t&&(a={profileId:e,profilePath:`${o}/${t.path}`,deprecated:!!t.deprecated}),!!a})),!a){if(!s)throw new Error("No matching profile name found");const e=i[s];if(!e)throw new Error(`No matching profile name found and default profile "${s}" missing.`);a={profileId:s,profilePath:`${o}/${e.path}`,deprecated:!!e.deprecated}}const r=await t(a.profilePath);let l;if(n){let t;if(t="any"===e.handedness?r.layouts[Object.keys(r.layouts)[0]]:r.layouts[e.handedness],!t)throw new Error(`No matching handedness, ${e.handedness}, in profile ${a.profileId}`);t.assetPath&&(l=a.profilePath.replace("profile.json",t.assetPath))}return{profile:r,assetPath:l}}const s={xAxis:0,yAxis:0,button:0,state:e.ComponentState.DEFAULT};class n{constructor(t){this.componentProperty=t.componentProperty,this.states=t.states,this.valueNodeName=t.valueNodeName,this.valueNodeProperty=t.valueNodeProperty,this.valueNodeProperty===e.VisualResponseProperty.TRANSFORM&&(this.minNodeName=t.minNodeName,this.maxNodeName=t.maxNodeName),this.value=0,this.updateFromComponent(s)}updateFromComponent({xAxis:t,yAxis:o,button:s,state:n}){const{normalizedXAxis:i,normalizedYAxis:a}=function(e=0,t=0){let o=e,s=t;if(Math.sqrt(e*e+t*t)>1){const n=Math.atan2(t,e);o=Math.cos(n),s=Math.sin(n)}return{normalizedXAxis:.5*o+.5,normalizedYAxis:.5*s+.5}}(t,o);switch(this.componentProperty){case e.ComponentProperty.X_AXIS:this.value=this.states.includes(n)?i:.5;break;case e.ComponentProperty.Y_AXIS:this.value=this.states.includes(n)?a:.5;break;case e.ComponentProperty.BUTTON:this.value=this.states.includes(n)?s:0;break;case e.ComponentProperty.STATE:this.valueNodeProperty===e.VisualResponseProperty.VISIBILITY?this.value=this.states.includes(n):this.value=this.states.includes(n)?1:0;break;default:throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`)}}}class i{constructor(t,o){if(!(t&&o&&o.visualResponses&&o.gamepadIndices&&0!==Object.keys(o.gamepadIndices).length))throw new Error("Invalid arguments supplied");this.id=t,this.type=o.type,this.rootNodeName=o.rootNodeName,this.touchPointNodeName=o.touchPointNodeName,this.visualResponses={},Object.keys(o.visualResponses).forEach((e=>{const t=new n(o.visualResponses[e]);this.visualResponses[e]=t})),this.gamepadIndices=Object.assign({},o.gamepadIndices),this.values={state:e.ComponentState.DEFAULT,button:void 0!==this.gamepadIndices.button?0:void 0,xAxis:void 0!==this.gamepadIndices.xAxis?0:void 0,yAxis:void 0!==this.gamepadIndices.yAxis?0:void 0}}get data(){return{id:this.id,...this.values}}updateFromGamepad(t){if(this.values.state=e.ComponentState.DEFAULT,void 0!==this.gamepadIndices.button&&t.buttons.length>this.gamepadIndices.button){const o=t.buttons[this.gamepadIndices.button];this.values.button=o.value,this.values.button=this.values.button<0?0:this.values.button,this.values.button=this.values.button>1?1:this.values.button,o.pressed||1===this.values.button?this.values.state=e.ComponentState.PRESSED:(o.touched||this.values.button>e.ButtonTouchThreshold)&&(this.values.state=e.ComponentState.TOUCHED)}void 0!==this.gamepadIndices.xAxis&&t.axes.length>this.gamepadIndices.xAxis&&(this.values.xAxis=t.axes[this.gamepadIndices.xAxis],this.values.xAxis=this.values.xAxis<-1?-1:this.values.xAxis,this.values.xAxis=this.values.xAxis>1?1:this.values.xAxis,this.values.state===e.ComponentState.DEFAULT&&Math.abs(this.values.xAxis)>e.AxisTouchThreshold&&(this.values.state=e.ComponentState.TOUCHED)),void 0!==this.gamepadIndices.yAxis&&t.axes.length>this.gamepadIndices.yAxis&&(this.values.yAxis=t.axes[this.gamepadIndices.yAxis],this.values.yAxis=this.values.yAxis<-1?-1:this.values.yAxis,this.values.yAxis=this.values.yAxis>1?1:this.values.yAxis,this.values.state===e.ComponentState.DEFAULT&&Math.abs(this.values.yAxis)>e.AxisTouchThreshold&&(this.values.state=e.ComponentState.TOUCHED)),Object.values(this.visualResponses).forEach((e=>{e.updateFromComponent(this.values)}))}}class a{constructor(e,t,o){if(!e)throw new Error("No xrInputSource supplied");if(!t)throw new Error("No profile supplied");this.xrInputSource=e,this.assetUrl=o,this.id=t.profileId,this.layoutDescription=t.layouts[e.handedness],this.components={},Object.keys(this.layoutDescription.components).forEach((e=>{const t=this.layoutDescription.components[e];this.components[e]=new i(e,t)})),this.updateFromGamepad()}get gripSpace(){return this.xrInputSource.gripSpace}get targetRaySpace(){return this.xrInputSource.targetRaySpace}get data(){const e=[];return Object.values(this.components).forEach((t=>{e.push(t.data)})),e}updateFromGamepad(){Object.values(this.components).forEach((e=>{e.updateFromGamepad(this.xrInputSource.gamepad)}))}}const{Mesh:r,MeshBasicMaterial:l,Object3D:d,SphereGeometry:h}=THREE;class c extends d{constructor(){super(),this.motionController=null,this.envMap=null}setEnvironmentMap(e){return this.envMap==e||(this.envMap=e,this.traverse((e=>{e.isMesh&&(e.material.envMap=this.envMap,e.material.needsUpdate=!0)}))),this}updateMatrixWorld(t){super.updateMatrixWorld(t),this.motionController&&(this.motionController.updateFromGamepad(),Object.values(this.motionController.components).forEach((t=>{Object.values(t.visualResponses).forEach((t=>{const{valueNode:o,minNode:s,maxNode:n,value:i,valueNodeProperty:a}=t;o&&(a===e.VisualResponseProperty.VISIBILITY?o.visible=i:a===e.VisualResponseProperty.TRANSFORM&&(o.quaternion.slerpQuaternions(s.quaternion,n.quaternion,i),o.position.lerpVectors(s.position,n.position,i)))}))})))}}function p(t,o){!function(t,o){Object.values(t.components).forEach((t=>{const{type:s,touchPointNodeName:n,visualResponses:i}=t;if(s===e.ComponentType.TOUCHPAD)if(t.touchPointNode=o.getObjectByName(n),t.touchPointNode){const e=new h(.001),o=new l({color:255}),s=new r(e,o);t.touchPointNode.add(s)}else console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);Object.values(i).forEach((t=>{const{valueNodeName:s,minNodeName:n,maxNodeName:i,valueNodeProperty:a}=t;if(a===e.VisualResponseProperty.TRANSFORM){if(t.minNode=o.getObjectByName(n),t.maxNode=o.getObjectByName(i),!t.minNode)return void console.warn(`Could not find ${n} in the model`);if(!t.maxNode)return void console.warn(`Could not find ${i} in the model`)}t.valueNode=o.getObjectByName(s),t.valueNode||console.warn(`Could not find ${s} in the model`)}))}))}(t.motionController,o),t.envMap&&o.traverse((e=>{e.isMesh&&(e.material.envMap=t.envMap,e.material.needsUpdate=!0)})),t.add(o)}class u{constructor(e,t){this.gltfLoader=e,this.path=t||"https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets/dist/profiles",this._assetCache={}}createControllerModel(e){const t=new c;let s=null;return e.addEventListener("connected",(e=>{const n=e.data;"tracked-pointer"===n.targetRayMode&&n.gamepad&&o(n,this.path,"generic-trigger").then((({profile:e,assetPath:o})=>{t.motionController=new a(n,e,o);const i=[],r=[],l={buttons:i,axes:r};if(t.gamepadMappings=l,t.motionController.layoutDescription?.components)for(let[e,o]of Object.entries(t.motionController.layoutDescription.components)){e=e.replace("xr-standard-","");for(const[t,s]of Object.entries(o.gamepadIndices))"button"===t?i[s]=e:r[s]={name:e,type:t}}const d=this._assetCache[t.motionController.assetUrl];if(d)s=d.scene.clone(),p(t,s);else{if(!this.gltfLoader)throw new Error("GLTFLoader not set.");this.gltfLoader.setPath(""),this.gltfLoader.load(t.motionController.assetUrl,(e=>{this._assetCache[t.motionController.assetUrl]=e,s=e.scene.clone(),p(t,s)}),null,(()=>{throw new Error(`Asset ${t.motionController.assetUrl} missing or malformed.`)}))}})).catch((e=>{console.warn(e)}))})),e.addEventListener("disconnected",(()=>{t.motionController=null,t.remove(s),s=null})),t}}const m="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets/dist/profiles",f=m+"/generic-hand",g="https://cdn.jsdelivr.net/npm/handy-work@2.4.0",b=g+"/poses/",v=(e,t,o)=>((e,t=0,o=1)=>Math.min(o,Math.max(t,e)))((o-e)/(t-e)),y=new Map,x=new Set,j=new THREE.Vector3,A=new THREE.Vector3,E=new THREE.Quaternion,N=new THREE.Quaternion,T=new THREE.Quaternion,w=["left","right","none"],S=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"];AFRAME.registerComponent("handy-controls",{schema:{renderGamepad:{oneOf:["any","left","right","none","never"],default:"any",description:"Whether to render a gamepad model when it's not doing hand tracking, right, none and left are the names of controller handedness, any is all of them, and never is to not draw gamepads"},left:{description:"URL for left controller",type:"model",default:f+"/left.glb"},right:{description:"URL for right controller",type:"model",default:f+"/right.glb"},materialOverride:{description:"Which hand to use the `material` component for",oneOf:["both","left","right","neither"],default:"both"},fuseVShort:{description:"Time for a pose to trigger a pose event (ms)",default:48},fuseShort:{description:"Time for a pose to trigger a pose_fuseShort event (ms)",default:480},fuseLong:{description:"Time for a pose to trigger a pose_fuseLong event (ms)",default:1440}},init(){const e=this.el.sceneEl;this.handyWorkCallback=this.handyWorkCallback.bind(this);const t=this.el.sceneEl.getAttribute("webxr"),o=t.optionalFeatures;o.includes("hand-tracking")||(o.push("hand-tracking"),this.el.sceneEl.setAttribute("webxr",t)),this.loader=new THREE.GLTFLoader;const s=this,n=this.el.sceneEl.systems["gltf-model"].getDRACOLoader(),i=this.el.sceneEl.systems["gltf-model"].getMeshoptDecoder();this.controllerModelFactory=new u(this.loader,m),this.model=null,n&&this.loader.setDRACOLoader(n),this.ready=i?i.then((function(e){s.loader.setMeshoptDecoder(e)})):Promise.resolve(),import("https://cdn.jsdelivr.net/npm/handy-work@2.4.0/build/esm/handy-work.standalone.js").then(function({update:e,loadPose:t,dumpHands:o,setPose:s,getPose:n}){this.handyWorkUpdate=e,this.dumpHands=o,this.loadPose=t,this.setPose=s,this.getPose=n,t("relax",b+"relax.handpose"),t("fist",b+"fist.handpose"),t("flat",b+"flat.handpose"),t("point",b+"point.handpose"),t("horns",b+"horns.handpose"),t("shaka",b+"shaka.handpose"),t("vulcan",b+"vulcan.handpose")}.bind(this));for(const e of w){const t=Array.from(this.el.querySelectorAll(`[data-${e}]`));for(const e of t)e.object3D.visible=!1}e.addEventListener("enter-vr",(()=>{for(const t of["select","selectstart","selectend","squeeze","squeezeend","squeezestart"])e.xrSession.addEventListener(t,this.eventFactory(t,this))})),this.elArrays={left:[],right:[],none:[]},this.elMaps={left:new Map,right:new Map,none:new Map};new MutationObserver(function e(){for(const e of w)s.elArrays[e].splice(0),s.elMaps[e].clear();const t=Array.from(s.el.querySelectorAll("[data-left],[data-right],[data-none]"));for(const e of t)for(const t of w)if(void 0!==e.dataset[t]){s.elArrays[t].push(e);const o=e.dataset[t],n=s.elMaps[t].get(o)||[];n.push(e),s.elMaps[t].set(o,n)}return e}.bind(this)()).observe(this.el,{childList:!0,attributes:!0,subtree:!0})},async gltfToJoints(e,t){const o=this.el;await this.ready;const s=(await new Promise(function(t,o){this.loader.load(e,t,void 0,o)}.bind(this))).scene.children[0],n=s.getObjectByProperty("type","SkinnedMesh");this.el.components.material&&("both"!==this.data.materialOverride&&this.data.materialOverride!==t||(n.material=this.el.components.material.material)),n.visible=!1,n.frustumCulled=!1,n.castShadow=!0,n.receiveShadow=!0,n.skeleton.pose();const i=[];for(const t of S){const o=s.getObjectByName(t);void 0!==o?(o.jointName=t,i.push(o),o.applyMatrix4(this.el.object3D.matrixWorld),o.updateMatrixWorld()):(console.warn(`Couldn't find ${t} in ${e} hand mesh`),i.push(void 0))}return o.setObject3D("hand-mesh-"+t,n),o.emit("model-loaded",{format:"gltf",model:n}),i},async update(e){const t=this.el,o=this.data.left,s=this.data.right;if(e.left===this.data.left&&e.right===this.data.right&&e.renderGamepad===this.data.renderGamepad||this.remove(),e.left!==this.data.left||e.right!==this.data.right)try{this.bonesRight=await this.gltfToJoints(s,"right"),this.bonesLeft=await this.gltfToJoints(o,"left")}catch(e){const o=e&&e.message?e.message:"Failed to load glTF model";console.warn(o),t.emit("hand-model-error",{message:o})}},eventFactory(e,t,o){function s(t){const o=this.el.sceneEl.xrSession,s=t.frame,n=t.inputSource,i=this.el.sceneEl.renderer.xr.getReferenceSpace(),a=s.getPose(n.targetRaySpace,i),r=t.inputSource.handedness,l={inputSource:n,handedness:r};if(!a)return;const d=this.elArrays[r];if("screen"===n.targetRayMode){const t=`screen-${Array.from(o.inputSources).filter((e=>"screen"===e.targetRayMode)).indexOf(n)}`;for(const o of d)o.dataset[r]===t&&(o.object3D.position.copy(a.transform.position),o.object3D.quaternion.copy(a.transform.orientation),o.object3D.visible=!1!==o.getDOMAttribute("visible"),o.emit(e,l))}else if(n.gamepad||n.hand)for(const t of d)t.emit(e,l)}return o?s.call(t,o):s.bind(t)},getControllerModel(e,t){const o=this.el.getObject3D("controller-model-"+t.handedness);if(o)return o;{const o=this.el.sceneEl.renderer.xr.getControllerGrip(e),s=this.controllerModelFactory.createControllerModel(o);return o.dispatchEvent({type:"connected",data:t}),this.el.setObject3D("controller-model-"+t.handedness,s),s}},tick(){const e=this.el.sceneEl.xrSession;if(!e)return;const t=this.el.sceneEl.renderer.xr.getReferenceSpace(),o=[],s=this.el.sceneEl.frame;for(const e of this.el.children)e.object3D.visible=!1;let n=0,i=0;e:for(const a of e.inputSources){const e=n++,r=this.el.querySelector(`[data-magnet][data-${a.handedness}]`);let l=null,d=1,h=[];const c=[];let p,u;const m=this.elArrays[a.handedness],f=this.elMaps[a.handedness];if(u=this.el.getObject3D("hand-mesh-"+a.handedness),a.hand){o.push(a);const e=this.el.getObject3D("controller-model-"+a.handedness);if(e&&(e.visible=!1),h="right"===a.handedness&&this.bonesRight||"left"===a.handedness&&this.bonesLeft,!h.length)continue;for(const e of h){const o=a.hand.get(e.jointName);if(c.push(e),o){if(u.visible&&f.has(e.jointName))for(const t of f.get(e.jointName))t.object3D.visible=!1!==t.getDOMAttribute("visible");const n=s.getJointPose(o,t);if(!n)continue e;if(u.visible=!0,f.has(e.jointName))for(const t of f.get(e.jointName))t.object3D.position.copy(n.transform.position),t.object3D.quaternion.copy(n.transform.orientation),void 0===t.dataset.noMagnet&&c.push(t.object3D);e.position.copy(n.transform.position),e.quaternion.copy(n.transform.orientation)}}}else u&&(u.visible=!1);if("screen"!==a.targetRayMode){for(const[e,o]of[["ray",a.targetRaySpace],["grip",a.gripSpace]])if(f.has(e)&&o){const n=s.getPose(o,t);if(n)for(const t of f.get(e))t.object3D.position.copy(n.transform.position),t.object3D.quaternion.copy(n.transform.orientation),t.object3D.visible=!1!==t.getDOMAttribute("visible"),void 0===t.dataset.noMagnet&&c.push(t.object3D)}if(("any"===this.data.renderGamepad||this.data.renderGamepad===a.handedness)&&a.gamepad&&!a.hand){if(p=this.getControllerModel(e,a),p.visible=!0,a.gripSpace){const e=s.getPose(a.gripSpace,t);e&&(p.position.copy(e.transform.position),p.quaternion.copy(e.transform.orientation),c.push(p))}const o=y.get(a),n={buttons:a.gamepad.buttons.map((e=>e.value)),axes:a.gamepad.axes.slice(0)};if(o){const e={handedness:a.handedness,inputSource:a,data:n};n.buttons.forEach(((t,s)=>{if(t!==o.buttons[s]){let o=p.gamepadMappings?.buttons[s]||`button${s}`;1===t?this.emitGamepad(m,`${o}down`,Object.assign({value:t},e)):this.emitGamepad(m,`${o}up`,Object.assign({value:t},e))}}));const t=p.gamepadMappings?.axes;if(t&&t.length){x.clear();const s={};if(t.forEach((({name:e},t)=>{if(e){n.axes[t]!==o.axes[t]&&x.add(e)}})),x.size){t.forEach((({name:e,type:t},o)=>{if(e&&x.has(e)){const i=n.axes[o];s[e]=s[e]||{},s[e][t.slice(0,1)]=i}}));for(const[t,o]of Object.entries(s))this.emitGamepad(m,`${t}moved`,Object.assign(o,e))}}else n.axes.forEach(((t,s)=>{let n=p.gamepadMappings?.axes[s]||`axes${s}`;t!==o.axes[s]&&this.emitGamepad(m,`${n}moved`,Object.assign({value:t},e))}))}y.set(a,n)}if(r){r.object3D.updateWorldMatrix(!0,!1);const e=Array.from(document.querySelectorAll(r.dataset.magnet)).sort(((e,t)=>Number(t.dataset.magnetPriority||1)-Number(e.dataset.magnetPriority||1)));r.object3D.getWorldPosition(j);for(const t of e){const[e,o]=(t.dataset.magnetRange||"0.2,0.1").split(",").map((e=>Number(e))),s=t.object3D.getWorldPosition(A).sub(j).length();if(s<e){l=t,d=v(e,void 0===o?e:o,s);break}}d>.5&&l&&l.id?r.dataset.magnetTarget=l.id:delete r.dataset.magnetTarget}if(l){this.el.object3D.worldToLocal(l.object3D.getWorldPosition(j)),A.copy(r.object3D.position),j.lerp(A,1-d).sub(A),this.el.object3D.getWorldQuaternion(T).invert(),l.object3D.getWorldQuaternion(E),E.premultiply(T),N.copy(r.object3D.quaternion),E.slerp(N,1-d).multiply(N.invert());for(const e of c)e.position.sub(A),e.position.applyQuaternion(E),e.position.add(A),e.applyQuaternion(E),e.position.add(j)}for(const e of h)e.applyMatrix4(this.el.object3D.matrixWorld),e.updateMatrixWorld()}else{const e="screen-"+i++;if(f.has(e)){const o=s.getPose(a.targetRaySpace,t);if(!o)continue e;for(const t of f.get(e))t.object3D.position.copy(o.transform.position),t.object3D.quaternion.copy(o.transform.orientation),t.object3D.visible=!1!==t.getDOMAttribute("visible")}}}o.length&&this.handyWorkUpdate&&this.handyWorkUpdate(o,t,s,this.handyWorkCallback)},handyWorkCallback:function({distances:e,handedness:t}){this.emitHandpose(e[0][0],t,{pose:e[0][0],poses:e,handedness:t})},emitGamepad(e,t,o){o.event=t;for(const s of e)s.emit(t,o,!1),s.emit("gamepad",o,!1)},emitHandpose(e,t,o){if(e===this[t+"_currentPose"])return;const s=Array.from(this.el.querySelectorAll(`[data-${t}]`));clearTimeout(this[t+"_vshortTimeout"]),clearTimeout(this[t+"_shortTimeout"]),clearTimeout(this[t+"_longTimeout"]),this[t+"_currentPose"]=e,this[t+"_vshortTimeout"]=setTimeout((()=>{for(const t of s)t.emit("pose_"+e,o,!1),t.emit("pose",o,!1)}),this.data.fuseVShort),this[t+"_shortTimeout"]=setTimeout((()=>{for(const t of s)t.emit("pose_"+e+"_fuseShort",o,!1)}),this.data.fuseShort),this[t+"_longTimeout"]=setTimeout((()=>{for(const t of s)t.emit("pose_"+e+"_fuseLong",o,!1)}),this.data.fuseLong)},remove(){this.bonesLeft&&(this.bonesLeft=null,this.el.removeObject3D("hand-mesh-left")),this.bonesRight&&(this.bonesRight=null,this.el.removeObject3D("hand-mesh-right")),this.el.getObject3D("controller-model-left")&&this.el.removeObject3D("controller-model-left"),this.el.getObject3D("controller-model-right")&&this.el.removeObject3D("controller-model-right"),this.el.getObject3D("controller-model-none")&&this.el.removeObject3D("controller-model-none")}})}();
//# sourceMappingURL=handy-controls.min.js.map
