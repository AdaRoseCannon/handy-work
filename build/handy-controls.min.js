!function(){"use strict";const e={Handedness:Object.freeze({NONE:"none",LEFT:"left",RIGHT:"right"}),ComponentState:Object.freeze({DEFAULT:"default",TOUCHED:"touched",PRESSED:"pressed"}),ComponentProperty:Object.freeze({BUTTON:"button",X_AXIS:"xAxis",Y_AXIS:"yAxis",STATE:"state"}),ComponentType:Object.freeze({TRIGGER:"trigger",SQUEEZE:"squeeze",TOUCHPAD:"touchpad",THUMBSTICK:"thumbstick",BUTTON:"button"}),ButtonTouchThreshold:.05,AxisTouchThreshold:.1,VisualResponseProperty:Object.freeze({TRANSFORM:"transform",VISIBILITY:"visibility"})};async function t(e){const t=await fetch(e);if(t.ok)return t.json();throw new Error(t.statusText)}async function o(e,o,s=null,n=!0){if(!e)throw new Error("No xrInputSource supplied");if(!o)throw new Error("No basePath supplied");const i=await async function(e){if(!e)throw new Error("No basePath supplied");return await t(`${e}/profilesList.json`)}(o);let a;if(e.profiles.some((e=>{const t=i[e];return t&&(a={profileId:e,profilePath:`${o}/${t.path}`,deprecated:!!t.deprecated}),!!a})),!a){if(!s)throw new Error("No matching profile name found");const e=i[s];if(!e)throw new Error(`No matching profile name found and default profile "${s}" missing.`);a={profileId:s,profilePath:`${o}/${e.path}`,deprecated:!!e.deprecated}}const r=await t(a.profilePath);let l;if(n){let t;if(t="any"===e.handedness?r.layouts[Object.keys(r.layouts)[0]]:r.layouts[e.handedness],!t)throw new Error(`No matching handedness, ${e.handedness}, in profile ${a.profileId}`);t.assetPath&&(l=a.profilePath.replace("profile.json",t.assetPath))}return{profile:r,assetPath:l}}const s={xAxis:0,yAxis:0,button:0,state:e.ComponentState.DEFAULT};class n{constructor(t){this.componentProperty=t.componentProperty,this.states=t.states,this.valueNodeName=t.valueNodeName,this.valueNodeProperty=t.valueNodeProperty,this.valueNodeProperty===e.VisualResponseProperty.TRANSFORM&&(this.minNodeName=t.minNodeName,this.maxNodeName=t.maxNodeName),this.value=0,this.updateFromComponent(s)}updateFromComponent({xAxis:t,yAxis:o,button:s,state:n}){const{normalizedXAxis:i,normalizedYAxis:a}=function(e=0,t=0){let o=e,s=t;if(Math.sqrt(e*e+t*t)>1){const n=Math.atan2(t,e);o=Math.cos(n),s=Math.sin(n)}return{normalizedXAxis:.5*o+.5,normalizedYAxis:.5*s+.5}}(t,o);switch(this.componentProperty){case e.ComponentProperty.X_AXIS:this.value=this.states.includes(n)?i:.5;break;case e.ComponentProperty.Y_AXIS:this.value=this.states.includes(n)?a:.5;break;case e.ComponentProperty.BUTTON:this.value=this.states.includes(n)?s:0;break;case e.ComponentProperty.STATE:this.valueNodeProperty===e.VisualResponseProperty.VISIBILITY?this.value=this.states.includes(n):this.value=this.states.includes(n)?1:0;break;default:throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`)}}}class i{constructor(t,o){if(!(t&&o&&o.visualResponses&&o.gamepadIndices&&0!==Object.keys(o.gamepadIndices).length))throw new Error("Invalid arguments supplied");this.id=t,this.type=o.type,this.rootNodeName=o.rootNodeName,this.touchPointNodeName=o.touchPointNodeName,this.visualResponses={},Object.keys(o.visualResponses).forEach((e=>{const t=new n(o.visualResponses[e]);this.visualResponses[e]=t})),this.gamepadIndices=Object.assign({},o.gamepadIndices),this.values={state:e.ComponentState.DEFAULT,button:void 0!==this.gamepadIndices.button?0:void 0,xAxis:void 0!==this.gamepadIndices.xAxis?0:void 0,yAxis:void 0!==this.gamepadIndices.yAxis?0:void 0}}get data(){return{id:this.id,...this.values}}updateFromGamepad(t){if(this.values.state=e.ComponentState.DEFAULT,void 0!==this.gamepadIndices.button&&t.buttons.length>this.gamepadIndices.button){const o=t.buttons[this.gamepadIndices.button];this.values.button=o.value,this.values.button=this.values.button<0?0:this.values.button,this.values.button=this.values.button>1?1:this.values.button,o.pressed||1===this.values.button?this.values.state=e.ComponentState.PRESSED:(o.touched||this.values.button>e.ButtonTouchThreshold)&&(this.values.state=e.ComponentState.TOUCHED)}void 0!==this.gamepadIndices.xAxis&&t.axes.length>this.gamepadIndices.xAxis&&(this.values.xAxis=t.axes[this.gamepadIndices.xAxis],this.values.xAxis=this.values.xAxis<-1?-1:this.values.xAxis,this.values.xAxis=this.values.xAxis>1?1:this.values.xAxis,this.values.state===e.ComponentState.DEFAULT&&Math.abs(this.values.xAxis)>e.AxisTouchThreshold&&(this.values.state=e.ComponentState.TOUCHED)),void 0!==this.gamepadIndices.yAxis&&t.axes.length>this.gamepadIndices.yAxis&&(this.values.yAxis=t.axes[this.gamepadIndices.yAxis],this.values.yAxis=this.values.yAxis<-1?-1:this.values.yAxis,this.values.yAxis=this.values.yAxis>1?1:this.values.yAxis,this.values.state===e.ComponentState.DEFAULT&&Math.abs(this.values.yAxis)>e.AxisTouchThreshold&&(this.values.state=e.ComponentState.TOUCHED)),Object.values(this.visualResponses).forEach((e=>{e.updateFromComponent(this.values)}))}}class a{constructor(e,t,o){if(!e)throw new Error("No xrInputSource supplied");if(!t)throw new Error("No profile supplied");this.xrInputSource=e,this.assetUrl=o,this.id=t.profileId,this.layoutDescription=t.layouts[e.handedness],this.components={},Object.keys(this.layoutDescription.components).forEach((e=>{const t=this.layoutDescription.components[e];this.components[e]=new i(e,t)})),this.updateFromGamepad()}get gripSpace(){return this.xrInputSource.gripSpace}get targetRaySpace(){return this.xrInputSource.targetRaySpace}get data(){const e=[];return Object.values(this.components).forEach((t=>{e.push(t.data)})),e}updateFromGamepad(){Object.values(this.components).forEach((e=>{e.updateFromGamepad(this.xrInputSource.gamepad)}))}}const{Mesh:r,MeshBasicMaterial:l,Object3D:d,SphereGeometry:h}=THREE;class c extends d{constructor(){super(),this.motionController=null,this.envMap=null}setEnvironmentMap(e){return this.envMap==e||(this.envMap=e,this.traverse((e=>{e.isMesh&&(e.material.envMap=this.envMap,e.material.needsUpdate=!0)}))),this}updateMatrixWorld(t){super.updateMatrixWorld(t),this.motionController&&(this.motionController.updateFromGamepad(),Object.values(this.motionController.components).forEach((t=>{Object.values(t.visualResponses).forEach((t=>{const{valueNode:o,minNode:s,maxNode:n,value:i,valueNodeProperty:a}=t;o&&(a===e.VisualResponseProperty.VISIBILITY?o.visible=i:a===e.VisualResponseProperty.TRANSFORM&&(o.quaternion.slerpQuaternions(s.quaternion,n.quaternion,i),o.position.lerpVectors(s.position,n.position,i)))}))})))}}function p(t,o){!function(t,o){Object.values(t.components).forEach((t=>{const{type:s,touchPointNodeName:n,visualResponses:i}=t;if(s===e.ComponentType.TOUCHPAD)if(t.touchPointNode=o.getObjectByName(n),t.touchPointNode){const e=new h(.001),o=new l({color:255}),s=new r(e,o);t.touchPointNode.add(s)}else console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);Object.values(i).forEach((t=>{const{valueNodeName:s,minNodeName:n,maxNodeName:i,valueNodeProperty:a}=t;if(a===e.VisualResponseProperty.TRANSFORM){if(t.minNode=o.getObjectByName(n),t.maxNode=o.getObjectByName(i),!t.minNode)return void console.warn(`Could not find ${n} in the model`);if(!t.maxNode)return void console.warn(`Could not find ${i} in the model`)}t.valueNode=o.getObjectByName(s),t.valueNode||console.warn(`Could not find ${s} in the model`)}))}))}(t.motionController,o),t.envMap&&o.traverse((e=>{e.isMesh&&(e.material.envMap=t.envMap,e.material.needsUpdate=!0)})),t.add(o)}class u{constructor(e){this.gltfLoader=e,this.path="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles",this._assetCache={}}createControllerModel(e){const t=new c;let s=null;return e.addEventListener("connected",(e=>{const n=e.data;"tracked-pointer"===n.targetRayMode&&n.gamepad&&o(n,this.path,"generic-trigger").then((({profile:e,assetPath:o})=>{t.motionController=new a(n,e,o);const i=this._assetCache[t.motionController.assetUrl];if(i)s=i.scene.clone(),p(t,s);else{if(!this.gltfLoader)throw new Error("GLTFLoader not set.");this.gltfLoader.setPath(""),this.gltfLoader.load(t.motionController.assetUrl,(e=>{this._assetCache[t.motionController.assetUrl]=e,s=e.scene.clone(),p(t,s)}),null,(()=>{throw new Error(`Asset ${t.motionController.assetUrl} missing or malformed.`)}))}})).catch((e=>{console.warn(e)}))})),e.addEventListener("disconnected",(()=>{t.motionController=null,t.remove(s),s=null})),t}}const m="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/",f="https://cdn.jsdelivr.net/npm/handy-work@1.5.0",g=f+"/poses/",b=(e,t,o)=>((e,t=0,o=1)=>Math.min(o,Math.max(t,e)))((o-e)/(t-e)),v=new Map,y=new THREE.Vector3,x=new THREE.Vector3,E=new THREE.Vector3,T=new THREE.Quaternion,w=new THREE.Quaternion;function j(e,t,o,s){e.position.sub(t),e.position.applyQuaternion(o),e.position.add(t),e.applyQuaternion(o),e.position.add(s)}const A=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"];AFRAME.registerComponent("handy-controls",{schema:{renderGamepad:{default:!0,description:"Whether to render a gamepad model when it's not doing hand tracking"},left:{description:"URL for left controller",type:"model",default:m+"left.glb"},right:{description:"URL for right controller",type:"model",default:m+"right.glb"},materialOverride:{description:"Which hand to use the `material` component for",oneOf:["both","left","right","none"],default:"both"},fuseVShort:{description:"Time for a pose to trigger a pose event (ms)",default:48},fuseShort:{description:"Time for a pose to trigger a pose_fuseShort event (ms)",default:480},fuseLong:{description:"Time for a pose to trigger a pose_fuseLong event (ms)",default:1440}},init(){this.handyWorkCallback=this.handyWorkCallback.bind(this);const e=this.el.sceneEl.getAttribute("webxr"),t=e.optionalFeatures;t.includes("hand-tracking")||(t.push("hand-tracking"),this.el.sceneEl.setAttribute("webxr",e)),this.loader=new THREE.GLTFLoader;const o=this,s=this.el.sceneEl.systems["gltf-model"].getDRACOLoader(),n=this.el.sceneEl.systems["gltf-model"].getMeshoptDecoder();this.controllerModelFactory=new u(this.loader),this.model=null,s&&this.loader.setDRACOLoader(s),this.ready=n?n.then((function(e){o.loader.setMeshoptDecoder(e)})):Promise.resolve(),import("https://cdn.jsdelivr.net/npm/handy-work@1.5.0/build/esm/handy-work.standalone.js").then(function({update:e,loadPose:t,dumpHands:o,setPose:s,getPose:n}){this.handyWorkUpdate=e,this.dumpHands=o,this.loadPose=t,this.setPose=s,this.getPose=n,t("relax",g+"relax.handpose"),t("fist",g+"fist.handpose"),t("flat",g+"flat.handpose"),t("point",g+"point.handpose"),t("horns",g+"horns.handpose"),t("shaka",g+"shaka.handpose"),t("vulcan",g+"vulcan.handpose")}.bind(this));for(const e of["left","right"]){const t=Array.from(this.el.querySelectorAll(`[data-${e}]`));for(const e of t)e.object3D.visible=!1}this.gripOffset={right:new THREE.Vector3(-.005,-.03,0),left:new THREE.Vector3(.005,-.03,0)},this.gripQuaternions={right:[(new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(0,0,-1),new THREE.Vector3(-1,0,0).normalize()),(new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(0,1,0),new THREE.Vector3(-1,0,0))],left:[(new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(0,0,1),new THREE.Vector3(1,0,0).normalize()),(new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(1,1,0),new THREE.Vector3(-1,0,-1))]}},async gltfToJoints(e,t){const o=this.el;await this.ready;const s=(await new Promise(function(t,o){this.loader.load(e,t,void 0,o)}.bind(this))).scene.children[0],n=s.getObjectByProperty("type","SkinnedMesh");this.el.components.material&&("both"!==this.data.materialOverride&&this.data.materialOverride!==t||(n.material=this.el.components.material.material)),n.visible=!1,n.frustumCulled=!1,n.castShadow=!0,n.receiveShadow=!0,n.skeleton.pose();const i=[];for(const t of A){const o=s.getObjectByName(t);void 0!==o?(o.jointName=t,i.push(o),o.applyMatrix4(this.el.object3D.matrixWorld),o.updateMatrixWorld()):(console.warn(`Couldn't find ${t} in ${e} hand mesh`),i.push(void 0))}return o.setObject3D("hand-mesh-"+t,n),o.emit("model-loaded",{format:"gltf",model:n}),i},async update(e){const t=this.el,o=this.data.left,s=this.data.right;if(e.left===this.data.left&&e.right===this.data.right&&e.renderGamepad===this.data.renderGamepad||this.remove(),e.left!==this.data.left||e.right!==this.data.right)try{this.bonesRight=await this.gltfToJoints(s,"right"),this.bonesLeft=await this.gltfToJoints(o,"left")}catch(e){const o=e&&e.message?e.message:"Failed to load glTF model";console.warn(o),t.emit("hand-model-error",{message:o})}},getControllerModel(e,t){const o=this.el.getObject3D("controller-model-"+t.handedness);if(o)return o;{const o=this.el.sceneEl.renderer.xr.getControllerGrip(e),s=this.controllerModelFactory.createControllerModel(o);return o.dispatchEvent({type:"connected",data:t}),this.el.setObject3D("controller-model-"+t.handedness,s),s}},tick(){const e=this.el.sceneEl.xrSession;if(!e)return;const t=this.el.sceneEl.renderer.xr.getReferenceSpace(),o=[],s=this.el.sceneEl.frame;let n=-1;e:for(const i of e.inputSources){n++;const e=this.el.querySelector(`[data-magnet][data-${i.handedness}]`);let a,r=null,l=1,d=[];const h=this.el.getObject3D("hand-mesh-"+i.handedness);if(!h)return;const c=Array.from(this.el.querySelectorAll(`[data-${i.handedness}]`)),p=new Map;for(const e of c){const t=e.dataset[i.handedness],o=p.get(t)||[];o.push(e),p.set(t,o)}if(i.hand){o.push(i);const e=this.el.getObject3D("controller-model-"+i.handedness);if(e&&(e.visible=!1),d="right"===i.handedness&&this.bonesRight||"left"===i.handedness&&this.bonesLeft,!d.length)continue;for(const e of d){const o=i.hand.get(e.jointName);if(o){const n=s.getJointPose(o,t);if(!n)continue e;if(h.visible=!0,p.has(e.jointName))for(const t of p.get(e.jointName))t.object3D.position.copy(n.transform.position),t.object3D.quaternion.copy(n.transform.orientation),t.object3D.visible=!1!==t.getDOMAttribute("visible");if("middle-finger-metacarpal"===e.jointName&&p.has("grip"))for(const e of p.get("grip"))e.object3D.quaternion.copy(n.transform.orientation),this.gripQuaternions[i.handedness].forEach((t=>e.object3D.quaternion.multiply(t))),e.object3D.position.copy(this.gripOffset[i.handedness]),e.object3D.position.applyQuaternion(e.object3D.quaternion),e.object3D.position.add(n.transform.position),e.object3D.visible=!1!==e.getDOMAttribute("visible");e.position.copy(n.transform.position),e.quaternion.copy(n.transform.orientation)}}}else{for(const e of c)e.object3D.visible=!1;if(h.visible=!1,this.data.renderGamepad&&(a=this.getControllerModel(n,i),a.visible=!0,i.gripSpace)){const e=s.getPose(i.gripSpace,t);if(e&&(a.position.copy(e.transform.position),a.quaternion.copy(e.transform.orientation),p.has("grip")))for(const t of p.get("grip"))t.object3D.position.copy(e.transform.position),t.object3D.quaternion.copy(e.transform.orientation),t.object3D.visible=!1!==t.getDOMAttribute("visible")}if(i.gamepad){const e=v.get(i),t={buttons:i.gamepad.buttons.map((e=>e.value)),axes:i.gamepad.axes.slice(0)};e&&(t.buttons.forEach(((o,s)=>{o!==e.buttons[s]&&(1===o?this.emitGamepad(c,`button${s}Down`,{value:o,handedness:i.handedness,inputSource:i,data:t}):this.emitGamepad(c,`button${s}Up`,{value:o,handedness:i.handedness,inputSource:i,data:t}))})),t.axes.forEach(((o,s)=>{o!==e.axes[s]&&(this.emitGamepad(c,`axes${s}Move`,{value:o,handedness:i.handedness,inputSource:i,data:t}),0===e.axes[s]&&this.emitGamepad(c,`axes${s}MoveStart`,{value:o,handedness:i.handedness,inputSource:i,data:t}),Math.abs(e.axes[s])<.5&&Math.abs(o)>.5&&this.emitGamepad(c,`axes${s}MoveMiddle`,{value:o,handedness:i.handedness,inputSource:i,data:t}),0===o&&this.emitGamepad(c,`axes${s}MoveEnd`,{value:o,handedness:i.handedness,inputSource:i,data:t}))}))),v.set(i,t)}}if(p.has("ray")&&i.targetRaySpace){const e=s.getPose(i.targetRaySpace,t);if(e)for(const t of p.get("ray"))t.object3D.position.copy(e.transform.position),t.object3D.quaternion.copy(e.transform.orientation),t.object3D.visible=!1!==t.getDOMAttribute("visible")}if(e){e.object3D.updateWorldMatrix(!0,!1);const t=Array.from(document.querySelectorAll(e.dataset.magnet));for(const o of t){const[t,s]=(o.dataset.magnetRange||"0.2,0.1").split(",").map((e=>Number(e)));o.object3D.getWorldPosition(y),e.object3D.worldToLocal(y);const n=y.length();if(n<t){r=o,l=s?b(t,s,n):1;break}}}if(r){r.object3D.getWorldPosition(x),e.object3D.getWorldPosition(E),x.lerp(E,1-l).sub(E),r.object3D.getWorldQuaternion(T),e.object3D.getWorldQuaternion(w),T.slerp(w,1-l).multiply(w.invert()),E.copy(e.object3D.position);for(const e of d)j(e,E,T,x),e.applyMatrix4(this.el.object3D.matrixWorld),e.updateMatrixWorld();for(const e of c.filter((e=>void 0===e.dataset.noMagnet)))j(e.object3D,E,T,x);a&&j(a,E,T,x)}else for(const e of d)e.applyMatrix4(this.el.object3D.matrixWorld),e.updateMatrixWorld()}o.length&&this.handyWorkUpdate&&this.handyWorkUpdate(o,t,s,this.handyWorkCallback)},handyWorkCallback:function({distances:e,handedness:t}){this.emit(e[0][0],t,{pose:e[0][0],poses:e,handedness:t})},emitGamepad(e,t,o){o.event=t,this.el.emit("gamepad_"+t,o),this.el.emit("gamepad",o);for(const s of e)s.emit("gamepad_"+t,o,!1),s.emit("gamepad",o,!1)},emit(e,t,o){if(e===this[t+"_currentPose"])return;const s=Array.from(this.el.querySelectorAll(`[data-${t}]`));clearTimeout(this[t+"_vshortTimeout"]),clearTimeout(this[t+"_shortTimeout"]),clearTimeout(this[t+"_longTimeout"]),this[t+"_currentPose"]=e,this[t+"_vshortTimeout"]=setTimeout((()=>{this.el.emit("pose_"+e,o),this.el.emit("pose",o);for(const t of s)t.emit("pose_"+e,o,!1),t.emit("pose",o,!1)}),this.data.fuseVShort),this[t+"_shortTimeout"]=setTimeout((()=>{this.el.emit("pose_"+e+"_fuseShort",o);for(const t of s)t.emit("pose_"+e+"_fuseShort",o,!1)}),this.data.fuseShort),this[t+"_longTimeout"]=setTimeout((()=>{this.el.emit("pose_"+e+"_fuseLong",o);for(const t of s)t.emit("pose_"+e+"_fuseLong",o,!1)}),this.data.fuseLong)},remove(){this.bonesLeft&&(this.bonesLeft=null,this.el.removeObject3D("hand-mesh-left")),this.bonesRight&&(this.bonesRight=null,this.el.removeObject3D("hand-mesh-right")),this.el.getObject3D("controller-model-left")&&this.el.removeObject3D("controller-model-left"),this.el.getObject3D("controller-model-right")&&this.el.removeObject3D("controller-model-right")}})}();
//# sourceMappingURL=handy-controls.min.js.map
