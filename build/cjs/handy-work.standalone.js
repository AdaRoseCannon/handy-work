'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const t=Symbol("Comlink.proxy"),s=Symbol("Comlink.endpoint"),e=Symbol("Comlink.releaseProxy"),i=Symbol("Comlink.thrown"),r=t=>"object"==typeof t&&null!==t||"function"==typeof t,n=new Map([["proxy",{canHandle:s=>r(s)&&s[t],serialize(t){const{port1:s,port2:e}=new MessageChannel;return h(t,s),[e,[e]]},deserialize:t=>(t.start(),o(t))}],["throw",{canHandle:t=>r(t)&&i in t,serialize({value:t}){let s;return s=t instanceof Error?{isError:!0,value:{message:t.message,name:t.name,stack:t.stack}}:{isError:!1,value:t},[s,[]]},deserialize(t){if(t.isError)throw Object.assign(new Error(t.value.message),t.value);throw t.value}}]]);function h(s,e=self){e.addEventListener("message",(function r(n){if(!n||!n.data)return;const{id:o,type:l,path:c}=Object.assign({path:[]},n.data),u=(n.data.argumentList||[]).map(_);let y;try{const e=c.slice(0,-1).reduce(((t,s)=>t[s]),s),i=c.reduce(((t,s)=>t[s]),s);switch(l){case"GET":y=i;break;case"SET":e[c.slice(-1)[0]]=_(n.data.value),y=!0;break;case"APPLY":y=i.apply(e,u);break;case"CONSTRUCT":y=function(s){return Object.assign(s,{[t]:!0})}(new i(...u));break;case"ENDPOINT":{const{port1:t,port2:e}=new MessageChannel;h(s,e),y=m(t,[t]);}break;case"RELEASE":y=void 0;break;default:return}}catch(t){y={value:t,[i]:0};}Promise.resolve(y).catch((t=>({value:t,[i]:0}))).then((t=>{const[s,i]=x(t);e.postMessage(Object.assign(Object.assign({},s),{id:o}),i),"RELEASE"===l&&(e.removeEventListener("message",r),a(e));}));})),e.start&&e.start();}function a(t){(function(t){return "MessagePort"===t.constructor.name})(t)&&t.close();}function o(t,s){return c(t,[],s)}function l(t){if(t)throw new Error("Proxy has been released and is not useable")}function c(t,i=[],r=function(){}){let n=!1;const h=new Proxy(r,{get(s,r){if(l(n),r===e)return ()=>z(t,{type:"RELEASE",path:i.map((t=>t.toString()))}).then((()=>{a(t),n=!0;}));if("then"===r){if(0===i.length)return {then:()=>h};const s=z(t,{type:"GET",path:i.map((t=>t.toString()))}).then(_);return s.then.bind(s)}return c(t,[...i,r])},set(s,e,r){l(n);const[h,a]=x(r);return z(t,{type:"SET",path:[...i,e].map((t=>t.toString())),value:h},a).then(_)},apply(e,r,h){l(n);const a=i[i.length-1];if(a===s)return z(t,{type:"ENDPOINT"}).then(_);if("bind"===a)return c(t,i.slice(0,-1));const[o,y]=u(h);return z(t,{type:"APPLY",path:i.map((t=>t.toString())),argumentList:o},y).then(_)},construct(s,e){l(n);const[r,h]=u(e);return z(t,{type:"CONSTRUCT",path:i.map((t=>t.toString())),argumentList:r},h).then(_)}});return h}function u(t){const s=t.map(x);return [s.map((t=>t[0])),(e=s.map((t=>t[1])),Array.prototype.concat.apply([],e))];var e;}const y=new WeakMap;function m(t,s){return y.set(t,s),t}function x(t){for(const[s,e]of n)if(e.canHandle(t)){const[i,r]=e.serialize(t);return [{type:"HANDLER",name:s,value:i},r]}return [{type:"RAW",value:t},y.get(t)||[]]}function _(t){switch(t.type){case"HANDLER":return n.get(t.name).deserialize(t.value);case"RAW":return t.value}}function z(t,s,e){return new Promise((i=>{const r=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");t.addEventListener("message",(function s(e){e.data&&e.data.id&&e.data.id===r&&(t.removeEventListener("message",s),i(e.data));})),t.start&&t.start(),t.postMessage(Object.assign({id:r},s),e);}))}const d=[];for(let t=0;t<256;t++)d[t]=(t<16?"0":"")+t.toString(16);function p(t,s,e){return Math.max(s,Math.min(e,t))}class M{constructor(t=0,s=0,e=0,i=1){this._x=t,this._y=s,this._z=e,this._w=i;}static slerp(t,s,e,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),e.slerpQuaternions(t,s,i)}static slerpFlat(t,s,e,i,r,n,h){let a=e[i+0],o=e[i+1],l=e[i+2],c=e[i+3];const u=r[n+0],y=r[n+1],m=r[n+2],x=r[n+3];if(0===h)return t[s+0]=a,t[s+1]=o,t[s+2]=l,void(t[s+3]=c);if(1===h)return t[s+0]=u,t[s+1]=y,t[s+2]=m,void(t[s+3]=x);if(c!==x||a!==u||o!==y||l!==m){let t=1-h;const s=a*u+o*y+l*m+c*x,e=s>=0?1:-1,i=1-s*s;if(i>Number.EPSILON){const r=Math.sqrt(i),n=Math.atan2(r,s*e);t=Math.sin(t*n)/r,h=Math.sin(h*n)/r;}const r=h*e;if(a=a*t+u*r,o=o*t+y*r,l=l*t+m*r,c=c*t+x*r,t===1-h){const t=1/Math.sqrt(a*a+o*o+l*l+c*c);a*=t,o*=t,l*=t,c*=t;}}t[s]=a,t[s+1]=o,t[s+2]=l,t[s+3]=c;}static multiplyQuaternionsFlat(t,s,e,i,r,n){const h=e[i],a=e[i+1],o=e[i+2],l=e[i+3],c=r[n],u=r[n+1],y=r[n+2],m=r[n+3];return t[s]=h*m+l*c+a*y-o*u,t[s+1]=a*m+l*u+o*c-h*y,t[s+2]=o*m+l*y+h*u-a*c,t[s+3]=l*m-h*c-a*u-o*y,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback();}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback();}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback();}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback();}set(t,s,e,i){return this._x=t,this._y=s,this._z=e,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,s){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const e=t._x,i=t._y,r=t._z,n=t._order,h=Math.cos,a=Math.sin,o=h(e/2),l=h(i/2),c=h(r/2),u=a(e/2),y=a(i/2),m=a(r/2);switch(n){case"XYZ":this._x=u*l*c+o*y*m,this._y=o*y*c-u*l*m,this._z=o*l*m+u*y*c,this._w=o*l*c-u*y*m;break;case"YXZ":this._x=u*l*c+o*y*m,this._y=o*y*c-u*l*m,this._z=o*l*m-u*y*c,this._w=o*l*c+u*y*m;break;case"ZXY":this._x=u*l*c-o*y*m,this._y=o*y*c+u*l*m,this._z=o*l*m+u*y*c,this._w=o*l*c-u*y*m;break;case"ZYX":this._x=u*l*c-o*y*m,this._y=o*y*c+u*l*m,this._z=o*l*m-u*y*c,this._w=o*l*c+u*y*m;break;case"YZX":this._x=u*l*c+o*y*m,this._y=o*y*c+u*l*m,this._z=o*l*m-u*y*c,this._w=o*l*c-u*y*m;break;case"XZY":this._x=u*l*c-o*y*m,this._y=o*y*c-u*l*m,this._z=o*l*m+u*y*c,this._w=o*l*c+u*y*m;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+n);}return !1!==s&&this._onChangeCallback(),this}setFromAxisAngle(t,s){const e=s/2,i=Math.sin(e);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(e),this._onChangeCallback(),this}setFromRotationMatrix(t){const s=t.elements,e=s[0],i=s[4],r=s[8],n=s[1],h=s[5],a=s[9],o=s[2],l=s[6],c=s[10],u=e+h+c;if(u>0){const t=.5/Math.sqrt(u+1);this._w=.25/t,this._x=(l-a)*t,this._y=(r-o)*t,this._z=(n-i)*t;}else if(e>h&&e>c){const t=2*Math.sqrt(1+e-h-c);this._w=(l-a)/t,this._x=.25*t,this._y=(i+n)/t,this._z=(r+o)/t;}else if(h>c){const t=2*Math.sqrt(1+h-e-c);this._w=(r-o)/t,this._x=(i+n)/t,this._y=.25*t,this._z=(a+l)/t;}else {const t=2*Math.sqrt(1+c-e-h);this._w=(n-i)/t,this._x=(r+o)/t,this._y=(a+l)/t,this._z=.25*t;}return this._onChangeCallback(),this}setFromUnitVectors(t,s){let e=t.dot(s)+1;return e<Number.EPSILON?(e=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=e):(this._x=0,this._y=-t.z,this._z=t.y,this._w=e)):(this._x=t.y*s.z-t.z*s.y,this._y=t.z*s.x-t.x*s.z,this._z=t.x*s.y-t.y*s.x,this._w=e),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(p(this.dot(t),-1,1)))}rotateTowards(t,s){const e=this.angleTo(t);if(0===e)return this;const i=Math.min(1,s/e);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,s){return void 0!==s?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,s)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,s){const e=t._x,i=t._y,r=t._z,n=t._w,h=s._x,a=s._y,o=s._z,l=s._w;return this._x=e*l+n*h+i*o-r*a,this._y=i*l+n*a+r*h-e*o,this._z=r*l+n*o+e*a-i*h,this._w=n*l-e*h-i*a-r*o,this._onChangeCallback(),this}slerp(t,s){if(0===s)return this;if(1===s)return this.copy(t);const e=this._x,i=this._y,r=this._z,n=this._w;let h=n*t._w+e*t._x+i*t._y+r*t._z;if(h<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,h=-h):this.copy(t),h>=1)return this._w=n,this._x=e,this._y=i,this._z=r,this;const a=1-h*h;if(a<=Number.EPSILON){const t=1-s;return this._w=t*n+s*this._w,this._x=t*e+s*this._x,this._y=t*i+s*this._y,this._z=t*r+s*this._z,this.normalize(),this._onChangeCallback(),this}const o=Math.sqrt(a),l=Math.atan2(o,h),c=Math.sin((1-s)*l)/o,u=Math.sin(s*l)/o;return this._w=n*c+this._w*u,this._x=e*c+this._x*u,this._y=i*c+this._y*u,this._z=r*c+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,s,e){return this.copy(t).slerp(s,e)}random(){const t=Math.random(),s=Math.sqrt(1-t),e=Math.sqrt(t),i=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(s*Math.cos(i),e*Math.sin(r),e*Math.cos(r),s*Math.sin(i))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,s=0){return this._x=t[s],this._y=t[s+1],this._z=t[s+2],this._w=t[s+3],this._onChangeCallback(),this}toArray(t=[],s=0){return t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._w,t}fromBufferAttribute(t,s){return this._x=t.getX(s),this._y=t.getY(s),this._z=t.getZ(s),this._w=t.getW(s),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}M.prototype.isQuaternion=!0;class f{constructor(t=0,s=0,e=0){this.x=t,this.y=s,this.z=e;}set(t,s,e){return void 0===e&&(e=this.z),this.x=t,this.y=s,this.z=e,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,s){return void 0!==s?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,s)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this.z+=t.z*s,this}sub(t,s){return void 0!==s?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,s)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this}multiply(t,s){return void 0!==s?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,s)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,s){return this.x=t.x*s.x,this.y=t.y*s.y,this.z=t.z*s.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(g.setFromEuler(t))}applyAxisAngle(t,s){return this.applyQuaternion(g.setFromAxisAngle(t,s))}applyMatrix3(t){const s=this.x,e=this.y,i=this.z,r=t.elements;return this.x=r[0]*s+r[3]*e+r[6]*i,this.y=r[1]*s+r[4]*e+r[7]*i,this.z=r[2]*s+r[5]*e+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const s=this.x,e=this.y,i=this.z,r=t.elements,n=1/(r[3]*s+r[7]*e+r[11]*i+r[15]);return this.x=(r[0]*s+r[4]*e+r[8]*i+r[12])*n,this.y=(r[1]*s+r[5]*e+r[9]*i+r[13])*n,this.z=(r[2]*s+r[6]*e+r[10]*i+r[14])*n,this}applyQuaternion(t){const s=this.x,e=this.y,i=this.z,r=t.x,n=t.y,h=t.z,a=t.w,o=a*s+n*i-h*e,l=a*e+h*s-r*i,c=a*i+r*e-n*s,u=-r*s-n*e-h*i;return this.x=o*a+u*-r+l*-h-c*-n,this.y=l*a+u*-n+c*-r-o*-h,this.z=c*a+u*-h+o*-n-l*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const s=this.x,e=this.y,i=this.z,r=t.elements;return this.x=r[0]*s+r[4]*e+r[8]*i,this.y=r[1]*s+r[5]*e+r[9]*i,this.z=r[2]*s+r[6]*e+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,s){return this.x=Math.max(t.x,Math.min(s.x,this.x)),this.y=Math.max(t.y,Math.min(s.y,this.y)),this.z=Math.max(t.z,Math.min(s.z,this.z)),this}clampScalar(t,s){return this.x=Math.max(t,Math.min(s,this.x)),this.y=Math.max(t,Math.min(s,this.y)),this.z=Math.max(t,Math.min(s,this.z)),this}clampLength(t,s){const e=this.length();return this.divideScalar(e||1).multiplyScalar(Math.max(t,Math.min(s,e)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this}lerpVectors(t,s,e){return this.x=t.x+(s.x-t.x)*e,this.y=t.y+(s.y-t.y)*e,this.z=t.z+(s.z-t.z)*e,this}cross(t,s){return void 0!==s?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,s)):this.crossVectors(this,t)}crossVectors(t,s){const e=t.x,i=t.y,r=t.z,n=s.x,h=s.y,a=s.z;return this.x=i*a-r*h,this.y=r*n-e*a,this.z=e*h-i*n,this}projectOnVector(t){const s=t.lengthSq();if(0===s)return this.set(0,0,0);const e=t.dot(this)/s;return this.copy(t).multiplyScalar(e)}projectOnPlane(t){return w.copy(this).projectOnVector(t),this.sub(w)}reflect(t){return this.sub(w.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const s=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===s)return Math.PI/2;const e=this.dot(t)/s;return Math.acos(p(e,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,e=this.y-t.y,i=this.z-t.z;return s*s+e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,s,e){const i=Math.sin(s)*t;return this.x=i*Math.sin(e),this.y=Math.cos(s)*t,this.z=i*Math.cos(e),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,s,e){return this.x=t*Math.sin(s),this.y=e,this.z=t*Math.cos(s),this}setFromMatrixPosition(t){const s=t.elements;return this.x=s[12],this.y=s[13],this.z=s[14],this}setFromMatrixScale(t){const s=this.setFromMatrixColumn(t,0).length(),e=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=s,this.y=e,this.z=i,this}setFromMatrixColumn(t,s){return this.fromArray(t.elements,4*s)}setFromMatrix3Column(t,s){return this.fromArray(t.elements,3*s)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this.z=t[s+2],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t[s+2]=this.z,t}fromBufferAttribute(t,s,e){return void 0!==e&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(s),this.y=t.getY(s),this.z=t.getZ(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),s=Math.random()*Math.PI*2,e=Math.sqrt(1-t**2);return this.x=e*Math.cos(s),this.y=e*Math.sin(s),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z;}}f.prototype.isVector3=!0;const w=new f,g=new M;class b{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");}set(t,s,e,i,r,n,h,a,o,l,c,u,y,m,x,_){const z=this.elements;return z[0]=t,z[4]=s,z[8]=e,z[12]=i,z[1]=r,z[5]=n,z[9]=h,z[13]=a,z[2]=o,z[6]=l,z[10]=c,z[14]=u,z[3]=y,z[7]=m,z[11]=x,z[15]=_,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return (new b).fromArray(this.elements)}copy(t){const s=this.elements,e=t.elements;return s[0]=e[0],s[1]=e[1],s[2]=e[2],s[3]=e[3],s[4]=e[4],s[5]=e[5],s[6]=e[6],s[7]=e[7],s[8]=e[8],s[9]=e[9],s[10]=e[10],s[11]=e[11],s[12]=e[12],s[13]=e[13],s[14]=e[14],s[15]=e[15],this}copyPosition(t){const s=this.elements,e=t.elements;return s[12]=e[12],s[13]=e[13],s[14]=e[14],this}setFromMatrix3(t){const s=t.elements;return this.set(s[0],s[3],s[6],0,s[1],s[4],s[7],0,s[2],s[5],s[8],0,0,0,0,1),this}extractBasis(t,s,e){return t.setFromMatrixColumn(this,0),s.setFromMatrixColumn(this,1),e.setFromMatrixColumn(this,2),this}makeBasis(t,s,e){return this.set(t.x,s.x,e.x,0,t.y,s.y,e.y,0,t.z,s.z,e.z,0,0,0,0,1),this}extractRotation(t){const s=this.elements,e=t.elements,i=1/E.setFromMatrixColumn(t,0).length(),r=1/E.setFromMatrixColumn(t,1).length(),n=1/E.setFromMatrixColumn(t,2).length();return s[0]=e[0]*i,s[1]=e[1]*i,s[2]=e[2]*i,s[3]=0,s[4]=e[4]*r,s[5]=e[5]*r,s[6]=e[6]*r,s[7]=0,s[8]=e[8]*n,s[9]=e[9]*n,s[10]=e[10]*n,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const s=this.elements,e=t.x,i=t.y,r=t.z,n=Math.cos(e),h=Math.sin(e),a=Math.cos(i),o=Math.sin(i),l=Math.cos(r),c=Math.sin(r);if("XYZ"===t.order){const t=n*l,e=n*c,i=h*l,r=h*c;s[0]=a*l,s[4]=-a*c,s[8]=o,s[1]=e+i*o,s[5]=t-r*o,s[9]=-h*a,s[2]=r-t*o,s[6]=i+e*o,s[10]=n*a;}else if("YXZ"===t.order){const t=a*l,e=a*c,i=o*l,r=o*c;s[0]=t+r*h,s[4]=i*h-e,s[8]=n*o,s[1]=n*c,s[5]=n*l,s[9]=-h,s[2]=e*h-i,s[6]=r+t*h,s[10]=n*a;}else if("ZXY"===t.order){const t=a*l,e=a*c,i=o*l,r=o*c;s[0]=t-r*h,s[4]=-n*c,s[8]=i+e*h,s[1]=e+i*h,s[5]=n*l,s[9]=r-t*h,s[2]=-n*o,s[6]=h,s[10]=n*a;}else if("ZYX"===t.order){const t=n*l,e=n*c,i=h*l,r=h*c;s[0]=a*l,s[4]=i*o-e,s[8]=t*o+r,s[1]=a*c,s[5]=r*o+t,s[9]=e*o-i,s[2]=-o,s[6]=h*a,s[10]=n*a;}else if("YZX"===t.order){const t=n*a,e=n*o,i=h*a,r=h*o;s[0]=a*l,s[4]=r-t*c,s[8]=i*c+e,s[1]=c,s[5]=n*l,s[9]=-h*l,s[2]=-o*l,s[6]=e*c+i,s[10]=t-r*c;}else if("XZY"===t.order){const t=n*a,e=n*o,i=h*a,r=h*o;s[0]=a*l,s[4]=-c,s[8]=o*l,s[1]=t*c+r,s[5]=n*l,s[9]=e*c-i,s[2]=i*c-e,s[6]=h*l,s[10]=r*c+t;}return s[3]=0,s[7]=0,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromQuaternion(t){return this.compose(S,t,k)}lookAt(t,s,e){const i=this.elements;return F.subVectors(t,s),0===F.lengthSq()&&(F.z=1),F.normalize(),v.crossVectors(e,F),0===v.lengthSq()&&(1===Math.abs(e.z)?F.x+=1e-4:F.z+=1e-4,F.normalize(),v.crossVectors(e,F)),v.normalize(),A.crossVectors(F,v),i[0]=v.x,i[4]=A.x,i[8]=F.x,i[1]=v.y,i[5]=A.y,i[9]=F.y,i[2]=v.z,i[6]=A.z,i[10]=F.z,this}multiply(t,s){return void 0!==s?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,s)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,s){const e=t.elements,i=s.elements,r=this.elements,n=e[0],h=e[4],a=e[8],o=e[12],l=e[1],c=e[5],u=e[9],y=e[13],m=e[2],x=e[6],_=e[10],z=e[14],d=e[3],p=e[7],M=e[11],f=e[15],w=i[0],g=i[4],b=i[8],E=i[12],C=i[1],S=i[5],k=i[9],v=i[13],A=i[2],F=i[6],R=i[10],T=i[14],V=i[3],P=i[7],q=i[11],L=i[15];return r[0]=n*w+h*C+a*A+o*V,r[4]=n*g+h*S+a*F+o*P,r[8]=n*b+h*k+a*R+o*q,r[12]=n*E+h*v+a*T+o*L,r[1]=l*w+c*C+u*A+y*V,r[5]=l*g+c*S+u*F+y*P,r[9]=l*b+c*k+u*R+y*q,r[13]=l*E+c*v+u*T+y*L,r[2]=m*w+x*C+_*A+z*V,r[6]=m*g+x*S+_*F+z*P,r[10]=m*b+x*k+_*R+z*q,r[14]=m*E+x*v+_*T+z*L,r[3]=d*w+p*C+M*A+f*V,r[7]=d*g+p*S+M*F+f*P,r[11]=d*b+p*k+M*R+f*q,r[15]=d*E+p*v+M*T+f*L,this}multiplyScalar(t){const s=this.elements;return s[0]*=t,s[4]*=t,s[8]*=t,s[12]*=t,s[1]*=t,s[5]*=t,s[9]*=t,s[13]*=t,s[2]*=t,s[6]*=t,s[10]*=t,s[14]*=t,s[3]*=t,s[7]*=t,s[11]*=t,s[15]*=t,this}determinant(){const t=this.elements,s=t[0],e=t[4],i=t[8],r=t[12],n=t[1],h=t[5],a=t[9],o=t[13],l=t[2],c=t[6],u=t[10],y=t[14];return t[3]*(+r*a*c-i*o*c-r*h*u+e*o*u+i*h*y-e*a*y)+t[7]*(+s*a*y-s*o*u+r*n*u-i*n*y+i*o*l-r*a*l)+t[11]*(+s*o*c-s*h*y-r*n*c+e*n*y+r*h*l-e*o*l)+t[15]*(-i*h*l-s*a*c+s*h*u+i*n*c-e*n*u+e*a*l)}transpose(){const t=this.elements;let s;return s=t[1],t[1]=t[4],t[4]=s,s=t[2],t[2]=t[8],t[8]=s,s=t[6],t[6]=t[9],t[9]=s,s=t[3],t[3]=t[12],t[12]=s,s=t[7],t[7]=t[13],t[13]=s,s=t[11],t[11]=t[14],t[14]=s,this}setPosition(t,s,e){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=s,i[14]=e),this}invert(){const t=this.elements,s=t[0],e=t[1],i=t[2],r=t[3],n=t[4],h=t[5],a=t[6],o=t[7],l=t[8],c=t[9],u=t[10],y=t[11],m=t[12],x=t[13],_=t[14],z=t[15],d=c*_*o-x*u*o+x*a*y-h*_*y-c*a*z+h*u*z,p=m*u*o-l*_*o-m*a*y+n*_*y+l*a*z-n*u*z,M=l*x*o-m*c*o+m*h*y-n*x*y-l*h*z+n*c*z,f=m*c*a-l*x*a-m*h*u+n*x*u+l*h*_-n*c*_,w=s*d+e*p+i*M+r*f;if(0===w)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const g=1/w;return t[0]=d*g,t[1]=(x*u*r-c*_*r-x*i*y+e*_*y+c*i*z-e*u*z)*g,t[2]=(h*_*r-x*a*r+x*i*o-e*_*o-h*i*z+e*a*z)*g,t[3]=(c*a*r-h*u*r-c*i*o+e*u*o+h*i*y-e*a*y)*g,t[4]=p*g,t[5]=(l*_*r-m*u*r+m*i*y-s*_*y-l*i*z+s*u*z)*g,t[6]=(m*a*r-n*_*r-m*i*o+s*_*o+n*i*z-s*a*z)*g,t[7]=(n*u*r-l*a*r+l*i*o-s*u*o-n*i*y+s*a*y)*g,t[8]=M*g,t[9]=(m*c*r-l*x*r-m*e*y+s*x*y+l*e*z-s*c*z)*g,t[10]=(n*x*r-m*h*r+m*e*o-s*x*o-n*e*z+s*h*z)*g,t[11]=(l*h*r-n*c*r-l*e*o+s*c*o+n*e*y-s*h*y)*g,t[12]=f*g,t[13]=(l*x*i-m*c*i+m*e*u-s*x*u-l*e*_+s*c*_)*g,t[14]=(m*h*i-n*x*i-m*e*a+s*x*a+n*e*_-s*h*_)*g,t[15]=(n*c*i-l*h*i+l*e*a-s*c*a-n*e*u+s*h*u)*g,this}scale(t){const s=this.elements,e=t.x,i=t.y,r=t.z;return s[0]*=e,s[4]*=i,s[8]*=r,s[1]*=e,s[5]*=i,s[9]*=r,s[2]*=e,s[6]*=i,s[10]*=r,s[3]*=e,s[7]*=i,s[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,s=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],e=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(s,e,i))}makeTranslation(t,s,e){return this.set(1,0,0,t,0,1,0,s,0,0,1,e,0,0,0,1),this}makeRotationX(t){const s=Math.cos(t),e=Math.sin(t);return this.set(1,0,0,0,0,s,-e,0,0,e,s,0,0,0,0,1),this}makeRotationY(t){const s=Math.cos(t),e=Math.sin(t);return this.set(s,0,e,0,0,1,0,0,-e,0,s,0,0,0,0,1),this}makeRotationZ(t){const s=Math.cos(t),e=Math.sin(t);return this.set(s,-e,0,0,e,s,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,s){const e=Math.cos(s),i=Math.sin(s),r=1-e,n=t.x,h=t.y,a=t.z,o=r*n,l=r*h;return this.set(o*n+e,o*h-i*a,o*a+i*h,0,o*h+i*a,l*h+e,l*a-i*n,0,o*a-i*h,l*a+i*n,r*a*a+e,0,0,0,0,1),this}makeScale(t,s,e){return this.set(t,0,0,0,0,s,0,0,0,0,e,0,0,0,0,1),this}makeShear(t,s,e,i,r,n){return this.set(1,e,r,0,t,1,n,0,s,i,1,0,0,0,0,1),this}compose(t,s,e){const i=this.elements,r=s._x,n=s._y,h=s._z,a=s._w,o=r+r,l=n+n,c=h+h,u=r*o,y=r*l,m=r*c,x=n*l,_=n*c,z=h*c,d=a*o,p=a*l,M=a*c,f=e.x,w=e.y,g=e.z;return i[0]=(1-(x+z))*f,i[1]=(y+M)*f,i[2]=(m-p)*f,i[3]=0,i[4]=(y-M)*w,i[5]=(1-(u+z))*w,i[6]=(_+d)*w,i[7]=0,i[8]=(m+p)*g,i[9]=(_-d)*g,i[10]=(1-(u+x))*g,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,s,e){const i=this.elements;let r=E.set(i[0],i[1],i[2]).length();const n=E.set(i[4],i[5],i[6]).length(),h=E.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],C.copy(this);const a=1/r,o=1/n,l=1/h;return C.elements[0]*=a,C.elements[1]*=a,C.elements[2]*=a,C.elements[4]*=o,C.elements[5]*=o,C.elements[6]*=o,C.elements[8]*=l,C.elements[9]*=l,C.elements[10]*=l,s.setFromRotationMatrix(C),e.x=r,e.y=n,e.z=h,this}makePerspective(t,s,e,i,r,n){void 0===n&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const h=this.elements,a=2*r/(s-t),o=2*r/(e-i),l=(s+t)/(s-t),c=(e+i)/(e-i),u=-(n+r)/(n-r),y=-2*n*r/(n-r);return h[0]=a,h[4]=0,h[8]=l,h[12]=0,h[1]=0,h[5]=o,h[9]=c,h[13]=0,h[2]=0,h[6]=0,h[10]=u,h[14]=y,h[3]=0,h[7]=0,h[11]=-1,h[15]=0,this}makeOrthographic(t,s,e,i,r,n){const h=this.elements,a=1/(s-t),o=1/(e-i),l=1/(n-r),c=(s+t)*a,u=(e+i)*o,y=(n+r)*l;return h[0]=2*a,h[4]=0,h[8]=0,h[12]=-c,h[1]=0,h[5]=2*o,h[9]=0,h[13]=-u,h[2]=0,h[6]=0,h[10]=-2*l,h[14]=-y,h[3]=0,h[7]=0,h[11]=0,h[15]=1,this}equals(t){const s=this.elements,e=t.elements;for(let t=0;t<16;t++)if(s[t]!==e[t])return !1;return !0}fromArray(t,s=0){for(let e=0;e<16;e++)this.elements[e]=t[e+s];return this}toArray(t=[],s=0){const e=this.elements;return t[s]=e[0],t[s+1]=e[1],t[s+2]=e[2],t[s+3]=e[3],t[s+4]=e[4],t[s+5]=e[5],t[s+6]=e[6],t[s+7]=e[7],t[s+8]=e[8],t[s+9]=e[9],t[s+10]=e[10],t[s+11]=e[11],t[s+12]=e[12],t[s+13]=e[13],t[s+14]=e[14],t[s+15]=e[15],t}}b.prototype.isMatrix4=!0;const E=new f,C=new b,S=new f(0,0,0),k=new f(1,1,1),v=new f,A=new f,F=new f;function R(t){const s=t.length/16,e=new b;e.fromArray(t,0),e.invert();const i=new b;for(let r=0;r<s;r++){const s=16*r;i.fromArray(t,s),i.premultiply(e),i.toArray(t,s);}}const T=o(new Worker(URL.createObjectURL(new Blob(['\nconst t=Symbol("Comlink.proxy"),s=Symbol("Comlink.endpoint"),e=Symbol("Comlink.releaseProxy"),i=Symbol("Comlink.thrown"),r=t=>"object"==typeof t&&null!==t||"function"==typeof t,n=new Map([["proxy",{canHandle:s=>r(s)&&s[t],serialize(t){const{port1:s,port2:e}=new MessageChannel;return h(t,s),[e,[e]]},deserialize(t){return t.start(),l(t,[],s);var s}}],["throw",{canHandle:t=>r(t)&&i in t,serialize({value:t}){let s;return s=t instanceof Error?{isError:!0,value:{message:t.message,name:t.name,stack:t.stack}}:{isError:!1,value:t},[s,[]]},deserialize(t){if(t.isError)throw Object.assign(new Error(t.value.message),t.value);throw t.value}}]]);function h(s,e=self){e.addEventListener("message",(function r(n){if(!n||!n.data)return;const{id:o,type:l,path:c}=Object.assign({path:[]},n.data),u=(n.data.argumentList||[]).map(x);let _;try{const e=c.slice(0,-1).reduce(((t,s)=>t[s]),s),i=c.reduce(((t,s)=>t[s]),s);switch(l){case"GET":_=i;break;case"SET":e[c.slice(-1)[0]]=x(n.data.value),_=!0;break;case"APPLY":_=i.apply(e,u);break;case"CONSTRUCT":_=function(s){return Object.assign(s,{[t]:!0})}(new i(...u));break;case"ENDPOINT":{const{port1:t,port2:e}=new MessageChannel;h(s,e),_=y(t,[t])}break;case"RELEASE":_=void 0;break;default:return}}catch(t){_={value:t,[i]:0}}Promise.resolve(_).catch((t=>({value:t,[i]:0}))).then((t=>{const[s,i]=m(t);e.postMessage(Object.assign(Object.assign({},s),{id:o}),i),"RELEASE"===l&&(e.removeEventListener("message",r),a(e))}))})),e.start&&e.start()}function a(t){(function(t){return"MessagePort"===t.constructor.name})(t)&&t.close()}function o(t){if(t)throw new Error("Proxy has been released and is not useable")}function l(t,i=[],r=function(){}){let n=!1;const h=new Proxy(r,{get(s,r){if(o(n),r===e)return()=>_(t,{type:"RELEASE",path:i.map((t=>t.toString()))}).then((()=>{a(t),n=!0}));if("then"===r){if(0===i.length)return{then:()=>h};const s=_(t,{type:"GET",path:i.map((t=>t.toString()))}).then(x);return s.then.bind(s)}return l(t,[...i,r])},set(s,e,r){o(n);const[h,a]=m(r);return _(t,{type:"SET",path:[...i,e].map((t=>t.toString())),value:h},a).then(x)},apply(e,r,h){o(n);const a=i[i.length-1];if(a===s)return _(t,{type:"ENDPOINT"}).then(x);if("bind"===a)return l(t,i.slice(0,-1));const[u,y]=c(h);return _(t,{type:"APPLY",path:i.map((t=>t.toString())),argumentList:u},y).then(x)},construct(s,e){o(n);const[r,h]=c(e);return _(t,{type:"CONSTRUCT",path:i.map((t=>t.toString())),argumentList:r},h).then(x)}});return h}function c(t){const s=t.map(m);return[s.map((t=>t[0])),(e=s.map((t=>t[1])),Array.prototype.concat.apply([],e))];var e}const u=new WeakMap;function y(t,s){return u.set(t,s),t}function m(t){for(const[s,e]of n)if(e.canHandle(t)){const[i,r]=e.serialize(t);return[{type:"HANDLER",name:s,value:i},r]}return[{type:"RAW",value:t},u.get(t)||[]]}function x(t){switch(t.type){case"HANDLER":return n.get(t.name).deserialize(t.value);case"RAW":return t.value}}function _(t,s,e){return new Promise((i=>{const r=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");t.addEventListener("message",(function s(e){e.data&&e.data.id&&e.data.id===r&&(t.removeEventListener("message",s),i(e.data))})),t.start&&t.start(),t.postMessage(Object.assign({id:r},s),e)}))}const z=[];for(let t=0;t<256;t++)z[t]=(t<16?"0":"")+t.toString(16);function p(t,s,e){return Math.max(s,Math.min(e,t))}class M{constructor(t=0,s=0,e=0,i=1){this._x=t,this._y=s,this._z=e,this._w=i}static slerp(t,s,e,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),e.slerpQuaternions(t,s,i)}static slerpFlat(t,s,e,i,r,n,h){let a=e[i+0],o=e[i+1],l=e[i+2],c=e[i+3];const u=r[n+0],y=r[n+1],m=r[n+2],x=r[n+3];if(0===h)return t[s+0]=a,t[s+1]=o,t[s+2]=l,void(t[s+3]=c);if(1===h)return t[s+0]=u,t[s+1]=y,t[s+2]=m,void(t[s+3]=x);if(c!==x||a!==u||o!==y||l!==m){let t=1-h;const s=a*u+o*y+l*m+c*x,e=s>=0?1:-1,i=1-s*s;if(i>Number.EPSILON){const r=Math.sqrt(i),n=Math.atan2(r,s*e);t=Math.sin(t*n)/r,h=Math.sin(h*n)/r}const r=h*e;if(a=a*t+u*r,o=o*t+y*r,l=l*t+m*r,c=c*t+x*r,t===1-h){const t=1/Math.sqrt(a*a+o*o+l*l+c*c);a*=t,o*=t,l*=t,c*=t}}t[s]=a,t[s+1]=o,t[s+2]=l,t[s+3]=c}static multiplyQuaternionsFlat(t,s,e,i,r,n){const h=e[i],a=e[i+1],o=e[i+2],l=e[i+3],c=r[n],u=r[n+1],y=r[n+2],m=r[n+3];return t[s]=h*m+l*c+a*y-o*u,t[s+1]=a*m+l*u+o*c-h*y,t[s+2]=o*m+l*y+h*u-a*c,t[s+3]=l*m-h*c-a*u-o*y,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,s,e,i){return this._x=t,this._y=s,this._z=e,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,s){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const e=t._x,i=t._y,r=t._z,n=t._order,h=Math.cos,a=Math.sin,o=h(e/2),l=h(i/2),c=h(r/2),u=a(e/2),y=a(i/2),m=a(r/2);switch(n){case"XYZ":this._x=u*l*c+o*y*m,this._y=o*y*c-u*l*m,this._z=o*l*m+u*y*c,this._w=o*l*c-u*y*m;break;case"YXZ":this._x=u*l*c+o*y*m,this._y=o*y*c-u*l*m,this._z=o*l*m-u*y*c,this._w=o*l*c+u*y*m;break;case"ZXY":this._x=u*l*c-o*y*m,this._y=o*y*c+u*l*m,this._z=o*l*m+u*y*c,this._w=o*l*c-u*y*m;break;case"ZYX":this._x=u*l*c-o*y*m,this._y=o*y*c+u*l*m,this._z=o*l*m-u*y*c,this._w=o*l*c+u*y*m;break;case"YZX":this._x=u*l*c+o*y*m,this._y=o*y*c+u*l*m,this._z=o*l*m-u*y*c,this._w=o*l*c-u*y*m;break;case"XZY":this._x=u*l*c-o*y*m,this._y=o*y*c-u*l*m,this._z=o*l*m+u*y*c,this._w=o*l*c+u*y*m;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+n)}return!1!==s&&this._onChangeCallback(),this}setFromAxisAngle(t,s){const e=s/2,i=Math.sin(e);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(e),this._onChangeCallback(),this}setFromRotationMatrix(t){const s=t.elements,e=s[0],i=s[4],r=s[8],n=s[1],h=s[5],a=s[9],o=s[2],l=s[6],c=s[10],u=e+h+c;if(u>0){const t=.5/Math.sqrt(u+1);this._w=.25/t,this._x=(l-a)*t,this._y=(r-o)*t,this._z=(n-i)*t}else if(e>h&&e>c){const t=2*Math.sqrt(1+e-h-c);this._w=(l-a)/t,this._x=.25*t,this._y=(i+n)/t,this._z=(r+o)/t}else if(h>c){const t=2*Math.sqrt(1+h-e-c);this._w=(r-o)/t,this._x=(i+n)/t,this._y=.25*t,this._z=(a+l)/t}else{const t=2*Math.sqrt(1+c-e-h);this._w=(n-i)/t,this._x=(r+o)/t,this._y=(a+l)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,s){let e=t.dot(s)+1;return e<Number.EPSILON?(e=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=e):(this._x=0,this._y=-t.z,this._z=t.y,this._w=e)):(this._x=t.y*s.z-t.z*s.y,this._y=t.z*s.x-t.x*s.z,this._z=t.x*s.y-t.y*s.x,this._w=e),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(p(this.dot(t),-1,1)))}rotateTowards(t,s){const e=this.angleTo(t);if(0===e)return this;const i=Math.min(1,s/e);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,s){return void 0!==s?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,s)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,s){const e=t._x,i=t._y,r=t._z,n=t._w,h=s._x,a=s._y,o=s._z,l=s._w;return this._x=e*l+n*h+i*o-r*a,this._y=i*l+n*a+r*h-e*o,this._z=r*l+n*o+e*a-i*h,this._w=n*l-e*h-i*a-r*o,this._onChangeCallback(),this}slerp(t,s){if(0===s)return this;if(1===s)return this.copy(t);const e=this._x,i=this._y,r=this._z,n=this._w;let h=n*t._w+e*t._x+i*t._y+r*t._z;if(h<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,h=-h):this.copy(t),h>=1)return this._w=n,this._x=e,this._y=i,this._z=r,this;const a=1-h*h;if(a<=Number.EPSILON){const t=1-s;return this._w=t*n+s*this._w,this._x=t*e+s*this._x,this._y=t*i+s*this._y,this._z=t*r+s*this._z,this.normalize(),this._onChangeCallback(),this}const o=Math.sqrt(a),l=Math.atan2(o,h),c=Math.sin((1-s)*l)/o,u=Math.sin(s*l)/o;return this._w=n*c+this._w*u,this._x=e*c+this._x*u,this._y=i*c+this._y*u,this._z=r*c+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,s,e){return this.copy(t).slerp(s,e)}random(){const t=Math.random(),s=Math.sqrt(1-t),e=Math.sqrt(t),i=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(s*Math.cos(i),e*Math.sin(r),e*Math.cos(r),s*Math.sin(i))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,s=0){return this._x=t[s],this._y=t[s+1],this._z=t[s+2],this._w=t[s+3],this._onChangeCallback(),this}toArray(t=[],s=0){return t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._w,t}fromBufferAttribute(t,s){return this._x=t.getX(s),this._y=t.getY(s),this._z=t.getZ(s),this._w=t.getW(s),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}M.prototype.isQuaternion=!0;class d{constructor(t=0,s=0,e=0){this.x=t,this.y=s,this.z=e}set(t,s,e){return void 0===e&&(e=this.z),this.x=t,this.y=s,this.z=e,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,s){return void 0!==s?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,s)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this.z+=t.z*s,this}sub(t,s){return void 0!==s?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,s)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this}multiply(t,s){return void 0!==s?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,s)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,s){return this.x=t.x*s.x,this.y=t.y*s.y,this.z=t.z*s.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(g.setFromEuler(t))}applyAxisAngle(t,s){return this.applyQuaternion(g.setFromAxisAngle(t,s))}applyMatrix3(t){const s=this.x,e=this.y,i=this.z,r=t.elements;return this.x=r[0]*s+r[3]*e+r[6]*i,this.y=r[1]*s+r[4]*e+r[7]*i,this.z=r[2]*s+r[5]*e+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const s=this.x,e=this.y,i=this.z,r=t.elements,n=1/(r[3]*s+r[7]*e+r[11]*i+r[15]);return this.x=(r[0]*s+r[4]*e+r[8]*i+r[12])*n,this.y=(r[1]*s+r[5]*e+r[9]*i+r[13])*n,this.z=(r[2]*s+r[6]*e+r[10]*i+r[14])*n,this}applyQuaternion(t){const s=this.x,e=this.y,i=this.z,r=t.x,n=t.y,h=t.z,a=t.w,o=a*s+n*i-h*e,l=a*e+h*s-r*i,c=a*i+r*e-n*s,u=-r*s-n*e-h*i;return this.x=o*a+u*-r+l*-h-c*-n,this.y=l*a+u*-n+c*-r-o*-h,this.z=c*a+u*-h+o*-n-l*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const s=this.x,e=this.y,i=this.z,r=t.elements;return this.x=r[0]*s+r[4]*e+r[8]*i,this.y=r[1]*s+r[5]*e+r[9]*i,this.z=r[2]*s+r[6]*e+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,s){return this.x=Math.max(t.x,Math.min(s.x,this.x)),this.y=Math.max(t.y,Math.min(s.y,this.y)),this.z=Math.max(t.z,Math.min(s.z,this.z)),this}clampScalar(t,s){return this.x=Math.max(t,Math.min(s,this.x)),this.y=Math.max(t,Math.min(s,this.y)),this.z=Math.max(t,Math.min(s,this.z)),this}clampLength(t,s){const e=this.length();return this.divideScalar(e||1).multiplyScalar(Math.max(t,Math.min(s,e)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this}lerpVectors(t,s,e){return this.x=t.x+(s.x-t.x)*e,this.y=t.y+(s.y-t.y)*e,this.z=t.z+(s.z-t.z)*e,this}cross(t,s){return void 0!==s?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,s)):this.crossVectors(this,t)}crossVectors(t,s){const e=t.x,i=t.y,r=t.z,n=s.x,h=s.y,a=s.z;return this.x=i*a-r*h,this.y=r*n-e*a,this.z=e*h-i*n,this}projectOnVector(t){const s=t.lengthSq();if(0===s)return this.set(0,0,0);const e=t.dot(this)/s;return this.copy(t).multiplyScalar(e)}projectOnPlane(t){return w.copy(this).projectOnVector(t),this.sub(w)}reflect(t){return this.sub(w.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const s=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===s)return Math.PI/2;const e=this.dot(t)/s;return Math.acos(p(e,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,e=this.y-t.y,i=this.z-t.z;return s*s+e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,s,e){const i=Math.sin(s)*t;return this.x=i*Math.sin(e),this.y=Math.cos(s)*t,this.z=i*Math.cos(e),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,s,e){return this.x=t*Math.sin(s),this.y=e,this.z=t*Math.cos(s),this}setFromMatrixPosition(t){const s=t.elements;return this.x=s[12],this.y=s[13],this.z=s[14],this}setFromMatrixScale(t){const s=this.setFromMatrixColumn(t,0).length(),e=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=s,this.y=e,this.z=i,this}setFromMatrixColumn(t,s){return this.fromArray(t.elements,4*s)}setFromMatrix3Column(t,s){return this.fromArray(t.elements,3*s)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this.z=t[s+2],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t[s+2]=this.z,t}fromBufferAttribute(t,s,e){return void 0!==e&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(s),this.y=t.getY(s),this.z=t.getZ(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),s=Math.random()*Math.PI*2,e=Math.sqrt(1-t**2);return this.x=e*Math.cos(s),this.y=e*Math.sin(s),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}d.prototype.isVector3=!0;const w=new d,g=new M;class f{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,s,e,i,r,n,h,a,o,l,c,u,y,m,x,_){const z=this.elements;return z[0]=t,z[4]=s,z[8]=e,z[12]=i,z[1]=r,z[5]=n,z[9]=h,z[13]=a,z[2]=o,z[6]=l,z[10]=c,z[14]=u,z[3]=y,z[7]=m,z[11]=x,z[15]=_,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new f).fromArray(this.elements)}copy(t){const s=this.elements,e=t.elements;return s[0]=e[0],s[1]=e[1],s[2]=e[2],s[3]=e[3],s[4]=e[4],s[5]=e[5],s[6]=e[6],s[7]=e[7],s[8]=e[8],s[9]=e[9],s[10]=e[10],s[11]=e[11],s[12]=e[12],s[13]=e[13],s[14]=e[14],s[15]=e[15],this}copyPosition(t){const s=this.elements,e=t.elements;return s[12]=e[12],s[13]=e[13],s[14]=e[14],this}setFromMatrix3(t){const s=t.elements;return this.set(s[0],s[3],s[6],0,s[1],s[4],s[7],0,s[2],s[5],s[8],0,0,0,0,1),this}extractBasis(t,s,e){return t.setFromMatrixColumn(this,0),s.setFromMatrixColumn(this,1),e.setFromMatrixColumn(this,2),this}makeBasis(t,s,e){return this.set(t.x,s.x,e.x,0,t.y,s.y,e.y,0,t.z,s.z,e.z,0,0,0,0,1),this}extractRotation(t){const s=this.elements,e=t.elements,i=1/b.setFromMatrixColumn(t,0).length(),r=1/b.setFromMatrixColumn(t,1).length(),n=1/b.setFromMatrixColumn(t,2).length();return s[0]=e[0]*i,s[1]=e[1]*i,s[2]=e[2]*i,s[3]=0,s[4]=e[4]*r,s[5]=e[5]*r,s[6]=e[6]*r,s[7]=0,s[8]=e[8]*n,s[9]=e[9]*n,s[10]=e[10]*n,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const s=this.elements,e=t.x,i=t.y,r=t.z,n=Math.cos(e),h=Math.sin(e),a=Math.cos(i),o=Math.sin(i),l=Math.cos(r),c=Math.sin(r);if("XYZ"===t.order){const t=n*l,e=n*c,i=h*l,r=h*c;s[0]=a*l,s[4]=-a*c,s[8]=o,s[1]=e+i*o,s[5]=t-r*o,s[9]=-h*a,s[2]=r-t*o,s[6]=i+e*o,s[10]=n*a}else if("YXZ"===t.order){const t=a*l,e=a*c,i=o*l,r=o*c;s[0]=t+r*h,s[4]=i*h-e,s[8]=n*o,s[1]=n*c,s[5]=n*l,s[9]=-h,s[2]=e*h-i,s[6]=r+t*h,s[10]=n*a}else if("ZXY"===t.order){const t=a*l,e=a*c,i=o*l,r=o*c;s[0]=t-r*h,s[4]=-n*c,s[8]=i+e*h,s[1]=e+i*h,s[5]=n*l,s[9]=r-t*h,s[2]=-n*o,s[6]=h,s[10]=n*a}else if("ZYX"===t.order){const t=n*l,e=n*c,i=h*l,r=h*c;s[0]=a*l,s[4]=i*o-e,s[8]=t*o+r,s[1]=a*c,s[5]=r*o+t,s[9]=e*o-i,s[2]=-o,s[6]=h*a,s[10]=n*a}else if("YZX"===t.order){const t=n*a,e=n*o,i=h*a,r=h*o;s[0]=a*l,s[4]=r-t*c,s[8]=i*c+e,s[1]=c,s[5]=n*l,s[9]=-h*l,s[2]=-o*l,s[6]=e*c+i,s[10]=t-r*c}else if("XZY"===t.order){const t=n*a,e=n*o,i=h*a,r=h*o;s[0]=a*l,s[4]=-c,s[8]=o*l,s[1]=t*c+r,s[5]=n*l,s[9]=e*c-i,s[2]=i*c-e,s[6]=h*l,s[10]=r*c+t}return s[3]=0,s[7]=0,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromQuaternion(t){return this.compose(C,t,k)}lookAt(t,s,e){const i=this.elements;return A.subVectors(t,s),0===A.lengthSq()&&(A.z=1),A.normalize(),S.crossVectors(e,A),0===S.lengthSq()&&(1===Math.abs(e.z)?A.x+=1e-4:A.z+=1e-4,A.normalize(),S.crossVectors(e,A)),S.normalize(),v.crossVectors(A,S),i[0]=S.x,i[4]=v.x,i[8]=A.x,i[1]=S.y,i[5]=v.y,i[9]=A.y,i[2]=S.z,i[6]=v.z,i[10]=A.z,this}multiply(t,s){return void 0!==s?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,s)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,s){const e=t.elements,i=s.elements,r=this.elements,n=e[0],h=e[4],a=e[8],o=e[12],l=e[1],c=e[5],u=e[9],y=e[13],m=e[2],x=e[6],_=e[10],z=e[14],p=e[3],M=e[7],d=e[11],w=e[15],g=i[0],f=i[4],b=i[8],E=i[12],C=i[1],k=i[5],S=i[9],v=i[13],A=i[2],F=i[6],R=i[10],T=i[14],V=i[3],q=i[7],P=i[11],L=i[15];return r[0]=n*g+h*C+a*A+o*V,r[4]=n*f+h*k+a*F+o*q,r[8]=n*b+h*S+a*R+o*P,r[12]=n*E+h*v+a*T+o*L,r[1]=l*g+c*C+u*A+y*V,r[5]=l*f+c*k+u*F+y*q,r[9]=l*b+c*S+u*R+y*P,r[13]=l*E+c*v+u*T+y*L,r[2]=m*g+x*C+_*A+z*V,r[6]=m*f+x*k+_*F+z*q,r[10]=m*b+x*S+_*R+z*P,r[14]=m*E+x*v+_*T+z*L,r[3]=p*g+M*C+d*A+w*V,r[7]=p*f+M*k+d*F+w*q,r[11]=p*b+M*S+d*R+w*P,r[15]=p*E+M*v+d*T+w*L,this}multiplyScalar(t){const s=this.elements;return s[0]*=t,s[4]*=t,s[8]*=t,s[12]*=t,s[1]*=t,s[5]*=t,s[9]*=t,s[13]*=t,s[2]*=t,s[6]*=t,s[10]*=t,s[14]*=t,s[3]*=t,s[7]*=t,s[11]*=t,s[15]*=t,this}determinant(){const t=this.elements,s=t[0],e=t[4],i=t[8],r=t[12],n=t[1],h=t[5],a=t[9],o=t[13],l=t[2],c=t[6],u=t[10],y=t[14];return t[3]*(+r*a*c-i*o*c-r*h*u+e*o*u+i*h*y-e*a*y)+t[7]*(+s*a*y-s*o*u+r*n*u-i*n*y+i*o*l-r*a*l)+t[11]*(+s*o*c-s*h*y-r*n*c+e*n*y+r*h*l-e*o*l)+t[15]*(-i*h*l-s*a*c+s*h*u+i*n*c-e*n*u+e*a*l)}transpose(){const t=this.elements;let s;return s=t[1],t[1]=t[4],t[4]=s,s=t[2],t[2]=t[8],t[8]=s,s=t[6],t[6]=t[9],t[9]=s,s=t[3],t[3]=t[12],t[12]=s,s=t[7],t[7]=t[13],t[13]=s,s=t[11],t[11]=t[14],t[14]=s,this}setPosition(t,s,e){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=s,i[14]=e),this}invert(){const t=this.elements,s=t[0],e=t[1],i=t[2],r=t[3],n=t[4],h=t[5],a=t[6],o=t[7],l=t[8],c=t[9],u=t[10],y=t[11],m=t[12],x=t[13],_=t[14],z=t[15],p=c*_*o-x*u*o+x*a*y-h*_*y-c*a*z+h*u*z,M=m*u*o-l*_*o-m*a*y+n*_*y+l*a*z-n*u*z,d=l*x*o-m*c*o+m*h*y-n*x*y-l*h*z+n*c*z,w=m*c*a-l*x*a-m*h*u+n*x*u+l*h*_-n*c*_,g=s*p+e*M+i*d+r*w;if(0===g)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const f=1/g;return t[0]=p*f,t[1]=(x*u*r-c*_*r-x*i*y+e*_*y+c*i*z-e*u*z)*f,t[2]=(h*_*r-x*a*r+x*i*o-e*_*o-h*i*z+e*a*z)*f,t[3]=(c*a*r-h*u*r-c*i*o+e*u*o+h*i*y-e*a*y)*f,t[4]=M*f,t[5]=(l*_*r-m*u*r+m*i*y-s*_*y-l*i*z+s*u*z)*f,t[6]=(m*a*r-n*_*r-m*i*o+s*_*o+n*i*z-s*a*z)*f,t[7]=(n*u*r-l*a*r+l*i*o-s*u*o-n*i*y+s*a*y)*f,t[8]=d*f,t[9]=(m*c*r-l*x*r-m*e*y+s*x*y+l*e*z-s*c*z)*f,t[10]=(n*x*r-m*h*r+m*e*o-s*x*o-n*e*z+s*h*z)*f,t[11]=(l*h*r-n*c*r-l*e*o+s*c*o+n*e*y-s*h*y)*f,t[12]=w*f,t[13]=(l*x*i-m*c*i+m*e*u-s*x*u-l*e*_+s*c*_)*f,t[14]=(m*h*i-n*x*i-m*e*a+s*x*a+n*e*_-s*h*_)*f,t[15]=(n*c*i-l*h*i+l*e*a-s*c*a-n*e*u+s*h*u)*f,this}scale(t){const s=this.elements,e=t.x,i=t.y,r=t.z;return s[0]*=e,s[4]*=i,s[8]*=r,s[1]*=e,s[5]*=i,s[9]*=r,s[2]*=e,s[6]*=i,s[10]*=r,s[3]*=e,s[7]*=i,s[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,s=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],e=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(s,e,i))}makeTranslation(t,s,e){return this.set(1,0,0,t,0,1,0,s,0,0,1,e,0,0,0,1),this}makeRotationX(t){const s=Math.cos(t),e=Math.sin(t);return this.set(1,0,0,0,0,s,-e,0,0,e,s,0,0,0,0,1),this}makeRotationY(t){const s=Math.cos(t),e=Math.sin(t);return this.set(s,0,e,0,0,1,0,0,-e,0,s,0,0,0,0,1),this}makeRotationZ(t){const s=Math.cos(t),e=Math.sin(t);return this.set(s,-e,0,0,e,s,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,s){const e=Math.cos(s),i=Math.sin(s),r=1-e,n=t.x,h=t.y,a=t.z,o=r*n,l=r*h;return this.set(o*n+e,o*h-i*a,o*a+i*h,0,o*h+i*a,l*h+e,l*a-i*n,0,o*a-i*h,l*a+i*n,r*a*a+e,0,0,0,0,1),this}makeScale(t,s,e){return this.set(t,0,0,0,0,s,0,0,0,0,e,0,0,0,0,1),this}makeShear(t,s,e,i,r,n){return this.set(1,e,r,0,t,1,n,0,s,i,1,0,0,0,0,1),this}compose(t,s,e){const i=this.elements,r=s._x,n=s._y,h=s._z,a=s._w,o=r+r,l=n+n,c=h+h,u=r*o,y=r*l,m=r*c,x=n*l,_=n*c,z=h*c,p=a*o,M=a*l,d=a*c,w=e.x,g=e.y,f=e.z;return i[0]=(1-(x+z))*w,i[1]=(y+d)*w,i[2]=(m-M)*w,i[3]=0,i[4]=(y-d)*g,i[5]=(1-(u+z))*g,i[6]=(_+p)*g,i[7]=0,i[8]=(m+M)*f,i[9]=(_-p)*f,i[10]=(1-(u+x))*f,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,s,e){const i=this.elements;let r=b.set(i[0],i[1],i[2]).length();const n=b.set(i[4],i[5],i[6]).length(),h=b.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],E.copy(this);const a=1/r,o=1/n,l=1/h;return E.elements[0]*=a,E.elements[1]*=a,E.elements[2]*=a,E.elements[4]*=o,E.elements[5]*=o,E.elements[6]*=o,E.elements[8]*=l,E.elements[9]*=l,E.elements[10]*=l,s.setFromRotationMatrix(E),e.x=r,e.y=n,e.z=h,this}makePerspective(t,s,e,i,r,n){void 0===n&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const h=this.elements,a=2*r/(s-t),o=2*r/(e-i),l=(s+t)/(s-t),c=(e+i)/(e-i),u=-(n+r)/(n-r),y=-2*n*r/(n-r);return h[0]=a,h[4]=0,h[8]=l,h[12]=0,h[1]=0,h[5]=o,h[9]=c,h[13]=0,h[2]=0,h[6]=0,h[10]=u,h[14]=y,h[3]=0,h[7]=0,h[11]=-1,h[15]=0,this}makeOrthographic(t,s,e,i,r,n){const h=this.elements,a=1/(s-t),o=1/(e-i),l=1/(n-r),c=(s+t)*a,u=(e+i)*o,y=(n+r)*l;return h[0]=2*a,h[4]=0,h[8]=0,h[12]=-c,h[1]=0,h[5]=2*o,h[9]=0,h[13]=-u,h[2]=0,h[6]=0,h[10]=-2*l,h[14]=-y,h[3]=0,h[7]=0,h[11]=0,h[15]=1,this}equals(t){const s=this.elements,e=t.elements;for(let t=0;t<16;t++)if(s[t]!==e[t])return!1;return!0}fromArray(t,s=0){for(let e=0;e<16;e++)this.elements[e]=t[e+s];return this}toArray(t=[],s=0){const e=this.elements;return t[s]=e[0],t[s+1]=e[1],t[s+2]=e[2],t[s+3]=e[3],t[s+4]=e[4],t[s+5]=e[5],t[s+6]=e[6],t[s+7]=e[7],t[s+8]=e[8],t[s+9]=e[9],t[s+10]=e[10],t[s+11]=e[11],t[s+12]=e[12],t[s+13]=e[13],t[s+14]=e[14],t[s+15]=e[15],t}}f.prototype.isMatrix4=!0;const b=new d,E=new f,C=new d(0,0,0),k=new d(1,1,1),S=new d,v=new d,A=new d;console.log("Worker started");const F=new Map,R=new f,T=new f,V=new M,q=new M;h(Object.freeze({__proto__:null,default:class{#t;constructor(){this.#t=[]}static async loadPose(t,s){const e=new URL(s),i=await fetch(e).then((t=>t.arrayBuffer())),r=new Float32Array(i);F.set(t,r)}static setPose(t,s){F.set(t,s)}static getPose(t){return F.get(t)}update(t,s,e){!function(t){const s=t.length/16,e=new f;e.fromArray(t,0),e.invert();const i=new f;for(let r=0;r<s;r++){const s=16*r;i.fromArray(t,s),i.premultiply(e),i.toArray(t,s)}}(s);const i=[];for(const[t,r]of F){const n=Number("right"===e),h=r[0],a=new Float32Array(r.buffer,4*(1+16*h*n),16*h),o=new Float32Array(r.buffer,4*(1+16*h*2+h*n),h),l=Math.min(h,s.length/16);let c=0,u=1e-4;for(let t=0;t<l;t++){const e=o[t];if(u+=e,0===t)continue;const i=16*t;R.fromArray(a,i),T.fromArray(s,i),V.setFromRotationMatrix(R),q.setFromRotationMatrix(T),c+=V.angleTo(q)*e}c/=u,i.push([t,c])}return y({usedHandArrayBuffer:s,distances:i.sort(((t,s)=>t[1]-s[1]))},[s.buffer])}getMatchedPoses(){return this.#t}}}));\n'])))).default;function V(t,s){return T.loadPose(t,s)}function P(t){return T.getPose(t)}function q(t,s){return T.setPose(t,s)}window.addEventListener("enter-vr",O),window.addEventListener("exit-vr",O);const L=new EventTarget;class j{#t;constructor({source:t,handPose:s}){this.handPose=s,this.size=t.hand.size,this.jointKeys=Array.from(t.hand.keys()),this.hand=t.hand,this.jointMatrixArray=new Float32Array(16*t.hand.size),this.handedness=t.handedness,this.#t=!0;}async update(t,s,e){if(!this.#t)return [];this.#t=!1,e.fillPoses(this.hand.values(),s,this.jointMatrixArray);const i=await this.handPose.update(t.transform.matrix,m(this.jointMatrixArray,[this.jointMatrixArray.buffer]),this.handedness);return this.jointMatrixArray=i.usedHandArrayBuffer,this.#t=!0,i.distances}}const H=new Map;function O(){H.clear();}let Q=!1;function Y(){Q=!0;}function N(t,s,e,i){const r={};for(const s of t)s.hand&&(r[s.handedness]=s.hand);if(r.left&&r.right){const t=r.left.size,n=1+16*t+16*t+t+t;if(void 0!==i&&i.byteLength<4*n)throw Error(`Provided buffer too small it needs to be a float32 and the size needs to be ${n} (${4*n} bytes)`);const h=i||new Float32Array(n);h[0]=t;const a=new Float32Array(h.buffer,4,16*t),o=new Float32Array(h.buffer,4+16*t*4,16*t);return new Float32Array(h.buffer,4+16*t*4*2,2*t).fill(1),e.fillPoses(r.left.values(),s,a),e.fillPoses(r.right.values(),s,o),R(a),R(o),h}}function X(t,s,e){const i={handedness:s.handedness,distances:t},r=new CustomEvent("pose",{detail:i});L.dispatchEvent(r),e&&e(i);}function Z(t,s,e,i){if(t&&e){if(undefined!==e.session&&function(t){t.addEventListener("reset",O),t.addEventListener("end",O),t.addEventListener("visibilitychange",O),t.addEventListener("inputsourceschange",O);}(e.session),Q){const i=N(t,s,e);i&&(Q=!1,function(t){const s=window.document.createElement("a");s.href=window.URL.createObjectURL(new Blob([new Uint8Array(t.buffer)],{type:"application/octet-stream"})),s.download="untitled.handpose",document.body.appendChild(s),s.click(),document.body.removeChild(s);}(i));}const r=e.getViewerPose(s);for(const n of t){const t=n.handedness;if(n.hand)if(H.has(t)){const n=H.get(t);if(n instanceof Promise)continue;n.update(r,s,e).then((t=>{t.length&&X(t,n,i);})).catch((function(t){console.log(t);}));}else {const s=new T;H.set(t,s),s.then((s=>{const i=e.session,r=new j({session:i,source:n,handPose:s});H.set(t,r);}));}}}}

exports.dumpHands = Y;
exports.generatePose = N;
exports.getPose = P;
exports.loadPose = V;
exports.resetHands = O;
exports.setPose = q;
exports.update = Z;
